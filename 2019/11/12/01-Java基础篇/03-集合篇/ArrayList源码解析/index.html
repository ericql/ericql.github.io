<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ArrayList源码解析 | Eric Liang</title><meta name="description" content="ArrayList源码解析"><meta name="keywords" content="集合,ArrayList"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="ArrayList源码解析"><meta name="twitter:description" content="ArrayList源码解析"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?book"><meta property="og:type" content="article"><meta property="og:title" content="ArrayList源码解析"><meta property="og:url" content="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="ArrayList源码解析"><meta property="og:image" content="https://source.unsplash.com/300x300/?book"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="prev" title="HashMap源码解析" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="next" title="04-ThreadPoolExecutor源码分析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/04-ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ArrayList源码解析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">ArrayList源码解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、ArrayList的定义"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">一、ArrayList的定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、ArrayList属性"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">二、ArrayList属性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-transient关键字"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">1.transient关键字</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三、ArrayList构造函数"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">三、ArrayList构造函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-Arrays-copyOf方法"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">1.Arrays.copyOf方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-System-arraycopy"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">2. System.arraycopy()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四、ArrayList容量处理"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">四、ArrayList容量处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-modCount解析"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.modCount解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五、核心函数分析"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">五、核心函数分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-indexOf"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">1.indexOf</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-lastIndexOf"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">2.lastIndexOf</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-clone"><span class="toc_mobile_items-number">1.5.3.</span> <span class="toc_mobile_items-text">3.clone</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-toArray"><span class="toc_mobile_items-number">1.5.4.</span> <span class="toc_mobile_items-text">4.toArray</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-add方法-重点"><span class="toc_mobile_items-number">1.5.5.</span> <span class="toc_mobile_items-text">5.add方法(重点)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#5-1无参构造时add运行"><span class="toc_mobile_items-number">1.5.5.1.</span> <span class="toc_mobile_items-text">5.1无参构造时add运行</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#5-2有参构造add运行"><span class="toc_mobile_items-number">1.5.5.2.</span> <span class="toc_mobile_items-text">5.2有参构造add运行</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-trimToSize"><span class="toc_mobile_items-number">1.5.6.</span> <span class="toc_mobile_items-text">6.trimToSize()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-removeAll和retainAll-重点"><span class="toc_mobile_items-number">1.5.7.</span> <span class="toc_mobile_items-text">7.removeAll和retainAll(重点)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1比较两种removeAll"><span class="toc_mobile_items-number">1.5.7.1.</span> <span class="toc_mobile_items-text">7.1比较两种removeAll</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-2Hash表简单介绍"><span class="toc_mobile_items-number">1.5.7.2.</span> <span class="toc_mobile_items-text">7.2Hash表简单介绍</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-遍历ArrayList的对象iterator"><span class="toc_mobile_items-number">1.5.8.</span> <span class="toc_mobile_items-text">8.遍历ArrayList的对象iterator</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#9-subList"><span class="toc_mobile_items-number">1.5.9.</span> <span class="toc_mobile_items-text">9.subList</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六、ArrayList的内部类"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">六、ArrayList的内部类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-Itr"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">1.Itr</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-ListItr"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">2.ListItr</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-SubList"><span class="toc_mobile_items-number">1.6.3.</span> <span class="toc_mobile_items-text">3.SubList</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-ArrayListSpliterator"><span class="toc_mobile_items-number">1.6.4.</span> <span class="toc_mobile_items-text">4.ArrayListSpliterator</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七、ArrayList源码全解析"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">七、ArrayList源码全解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#八、ArrayList总结"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">八、ArrayList总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#九、c-toArray的官方bug"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">九、c.toArray的官方bug</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-代码分析"><span class="toc_mobile_items-number">1.9.1.</span> <span class="toc_mobile_items-text">1.代码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1创建类"><span class="toc_mobile_items-number">1.9.1.1.</span> <span class="toc_mobile_items-text">1.1创建类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2测试1"><span class="toc_mobile_items-number">1.9.1.2.</span> <span class="toc_mobile_items-text">1.2测试1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-3测试2"><span class="toc_mobile_items-number">1.9.1.3.</span> <span class="toc_mobile_items-text">1.3测试2</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList源码解析"><span class="toc-number">1.</span> <span class="toc-text">ArrayList源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、ArrayList的定义"><span class="toc-number">1.1.</span> <span class="toc-text">一、ArrayList的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、ArrayList属性"><span class="toc-number">1.2.</span> <span class="toc-text">二、ArrayList属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-transient关键字"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.transient关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、ArrayList构造函数"><span class="toc-number">1.3.</span> <span class="toc-text">三、ArrayList构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Arrays-copyOf方法"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.Arrays.copyOf方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-System-arraycopy"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. System.arraycopy()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ArrayList容量处理"><span class="toc-number">1.4.</span> <span class="toc-text">四、ArrayList容量处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-modCount解析"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.modCount解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、核心函数分析"><span class="toc-number">1.5.</span> <span class="toc-text">五、核心函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-indexOf"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.indexOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-lastIndexOf"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.lastIndexOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-clone"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-toArray"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.toArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-add方法-重点"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.add方法(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1无参构造时add运行"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">5.1无参构造时add运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2有参构造add运行"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">5.2有参构造add运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-trimToSize"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.trimToSize()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-removeAll和retainAll-重点"><span class="toc-number">1.5.7.</span> <span class="toc-text">7.removeAll和retainAll(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1比较两种removeAll"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">7.1比较两种removeAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2Hash表简单介绍"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">7.2Hash表简单介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-遍历ArrayList的对象iterator"><span class="toc-number">1.5.8.</span> <span class="toc-text">8.遍历ArrayList的对象iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-subList"><span class="toc-number">1.5.9.</span> <span class="toc-text">9.subList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、ArrayList的内部类"><span class="toc-number">1.6.</span> <span class="toc-text">六、ArrayList的内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Itr"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.Itr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ListItr"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.ListItr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SubList"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.SubList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ArrayListSpliterator"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.ArrayListSpliterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、ArrayList源码全解析"><span class="toc-number">1.7.</span> <span class="toc-text">七、ArrayList源码全解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、ArrayList总结"><span class="toc-number">1.8.</span> <span class="toc-text">八、ArrayList总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、c-toArray的官方bug"><span class="toc-number">1.9.</span> <span class="toc-text">九、c.toArray的官方bug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-代码分析"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1创建类"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">1.1创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2测试1"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">1.2测试1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3测试2"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">1.3测试2</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">ArrayList源码解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-01</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/">01-Java基础篇</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E8%A7%A3%E6%9E%90/">03-集合解析</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h1><h2 id="一、ArrayList的定义"><a href="#一、ArrayList的定义" class="headerlink" title="一、ArrayList的定义"></a>一、ArrayList的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从ArrayList<e>可以看出它是支持泛型的,它继承自AbstractList,实现List、RandomAccess、Cloneable、java.io.Serializable接口<br>&emsp;&emsp;AbstractList提供了List接口的默认实现(个别方法为抽象方法),List接口定义了列表必须实现的方法<br>&emsp;&emsp;RandomAccess是一个标记接口,接口内没有定义任何内容<br>&emsp;&emsp;实现了Cloneable接口的类,可以调用Object.clone方法返回该对象的浅拷贝<br>&emsp;&emsp;通过实现java.io.Serializable接口以启用其序列化功能,未实现此接口的类将无法使其任何状态序列化或反序列化.序列化接口没有方法和字段,仅用于标识可序列化的语义</e></p>
<h2 id="二、ArrayList属性"><a href="#二、ArrayList属性" class="headerlink" title="二、ArrayList属性"></a>二、ArrayList属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个空数组:当用户指定该ArrayList容量为0时,返回该空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个空数组实例:</span></span><br><span class="line"><span class="comment"> *  当用户没有指定ArrayList的容量时(即调用无参构造函数),返回的是该数组---&gt;刚创建一个ArrayList时,其内数据量为0</span></span><br><span class="line"><span class="comment"> *  当用户第一次添加元素时,该数组(同引用与elementData)将会扩容,变成默认容量为10(DEFAULT_CAPACITY)的一个数组---&gt;通过ensureCapacityInternal() 实现</span></span><br><span class="line"><span class="comment"> *  它与EMPTY_ELEMENTDATA的区别就是：该数组是默认返回的,而后者是在用户指定容量为0时返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList基于数组实现:用该数组保存数据,ArrayList的容量就是该数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList实际存储的数据数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<h3 id="1-transient关键字"><a href="#1-transient关键字" class="headerlink" title="1.transient关键字"></a>1.transient关键字</h3><p>此处有个关键字需要解释:<br>&emsp;&emsp;Java的serialization提供了一种持久化对象实例的机制.当持久化对象时,可能有一个特殊的对象数据成员,我们不想用serialization机制来保存它,为了在一个特定对象的一个域上关闭serialization,可以在这个域前加上关键字transient<br>&emsp;&emsp;transient是Java语言的关键字,用来表示一个域不是该对象串行化的一部分,当一个对象被串行化的时候,transient型变量的值不包括在串行化表示中,然后非transient型的变量是被包括进行的  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3091184167089157794L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String psw;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(String name, String psw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.psw = psw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserInfo&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", psw='"</span> + psw + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"张三"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化,被设置为transient属性的没有序列化</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"UserInfo.out"</span>));</span><br><span class="line">            oos.writeObject(userInfo);</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//重新读取内容</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"UserInfo.out"</span>));</span><br><span class="line">            UserInfo userInfo1 = (UserInfo) ois.readObject();</span><br><span class="line">            System.out.println(userInfo1.toString()); <span class="comment">//发现psw内容为null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、ArrayList构造函数"><a href="#三、ArrayList构造函数" class="headerlink" title="三、ArrayList构造函数"></a>三、ArrayList构造函数</h2><p>ArrayList提供了三个构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个初始容量/空的ArrayList</span></span><br><span class="line"><span class="comment"> * -可能报错 java.lang.OutOfMemoryError 需要的Array size超过VM限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当初始容量值非法(小于0)时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组缓冲区为EMPTY_ELEMENTDATA,注意与 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数:</span></span><br><span class="line"><span class="comment"> *  初始时创建一个空的ArrayList,此时其内数组缓冲区elementData = &#123;&#125;,长度为0</span></span><br><span class="line"><span class="comment"> *  当元素第一次被加入时,扩容至默认容量10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> * 创建一个包含collection的ArrayList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要放入ArrayList中的集合,其内元素将会全部添加到新建的ArrayList实例中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 当参数c为null时抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray(); <span class="comment">//集合转Object[]数组</span></span><br><span class="line">    <span class="comment">//将转换后Object[]长度赋值给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">// c.toArray可能不会返回Object[],可以查看java官方编号6260652的bug</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//若c.toArray可能不会返回Object[],则利用Arrays.copyof()来构造一个大小为size的Object[]数组</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="comment">//长度为0则换成空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-Arrays-copyOf方法"><a href="#1-Arrays-copyOf方法" class="headerlink" title="1.Arrays.copyOf方法"></a>1.Arrays.copyOf方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非基本类型copyOf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original:要复制的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength:要返回的副本长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newType:要返回的副本的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;  </span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]  </span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,  Math.min(original.length, newLength));  </span><br><span class="line">    <span class="keyword">return</span> copy;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;  </span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];  </span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,  Math.min(original.length, newLength));  </span><br><span class="line">    <span class="keyword">return</span> copy;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察源代码发现copyOf(),在其内部创建了一个新的数组,然后调用arrayCopy()产生新的数组对象返回;总结如下：</p>
<ol>
<li>copyOf()实现用的是arrayCopy()</li>
<li>arrayCopy()需要目标数组,对两个数组的内容进行可能不完全的合并操作</li>
<li>copyOf()在内部新建一个数组,是用arrayCopy()将oldArray内容复制到newArray中去,并且长度为newLength,返回newArray</li>
</ol>
<h3 id="2-System-arraycopy"><a href="#2-System-arraycopy" class="headerlink" title="2. System.arraycopy()"></a>2. System.arraycopy()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src - 源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos - 源数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest - 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos - 目标数据中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length - 要复制数组的元素数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法用了native关键字,调用的是C++编写的底层函数,即JDK中的底层函数<br><font color="red">在实际使用中,如果我们能对所需的ArrayList的大小进行判断</font>,有两个好处:</p>
<ul>
<li>节省内存空间(我们只需放置两个元素到数组—new ArrayList<string>(2))</string></li>
<li>避免数组扩容引起效率下降(我们只需要放置大约37个元素到数组,new ArrayList<string>(40))</string></li>
</ul>
<h2 id="四、ArrayList容量处理"><a href="#四、ArrayList容量处理" class="headerlink" title="四、ArrayList容量处理"></a>四、ArrayList容量处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组缓冲区大小调整为实际ArrayList存储元素的大小</span></span><br><span class="line"><span class="comment"> * 即elementData = Arrays.copy(elementData, size)</span></span><br><span class="line"><span class="comment"> * 该方法ArrayList没有使用,由用户手动调用,以减少空间资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//modCount 是 AbstractList 的属性值: protected transient int modCount = 0;</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当实际大小 &lt; 数组缓冲区大小时(如调用默认构造函数后,刚添加一个元素时,此时elementData.length = 10,而size = 1)</span></span><br><span class="line">    <span class="comment">//通过这一步,可以使得空间得到有效利用,而不会出现资源浪费的情况</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">//注意此处的运算符优先级:先判断后把数组赋给elementData</span></span><br><span class="line">        <span class="comment">//调整数组缓冲区elementData变为实际存储大小</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">                ? EMPTY_ELEMENTDATA</span><br><span class="line">                : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定ArrayList的容量</span></span><br><span class="line"><span class="comment"> * 此方法提供给用户使用,在ArrayList中并没有使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   指定的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最小扩充容量,默认是10</span></span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="comment">//若用户指定的最小容量 &gt; 最小扩充容量,则以用户指定的为准,否则还是10</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法,明确ArrayList的容量,提供给本类使用的方法</span></span><br><span class="line"><span class="comment"> * 用于内部优化,保证空间资源不被浪费,尤其在add()方法添加时起效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 指定的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若elementData==&#123;&#125;时,则取minCapacity为 默认容量10 和 参数minCapacity 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法:明确ArrayList的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 指定的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将修改统计数+1,该变量主要是用来实现fail-fast机制的</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止溢出代码:确保指定的最小容量 &gt; 数组缓冲区当前长度</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组缓冲区的最大存储容量:</span></span><br><span class="line"><span class="comment"> *  减去8的原因 ---&gt; 一些VM会在一个数组中存储某些数组</span></span><br><span class="line"><span class="comment"> *  尝试分配这个最大存储容量,可能会导致OutOfMemoryError(当值&gt;VM限制时)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法:扩容 以确保ArrayList至少能存储minCapacity个元素</span></span><br><span class="line"><span class="comment"> * 扩容计算: newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 指定的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止溢出代码</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//若newCapacity 依旧小于 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若newCapacity 大于 最大存储容量,则进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法:大容量分配,最大分配Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-modCount解析"><a href="#1-modCount解析" class="headerlink" title="1.modCount解析"></a>1.modCount解析</h3><p>&emsp;&emsp;首先modCount是从类java.util.AbstractList继承的字段,这个字段主要是为了防止在多线程操作的情况下,List发生结构性的变化<br>&emsp;&emsp;就是防止一个线程正在迭代,另外一个线程进行对List进行remove操作,这样当我们迭代到最后一个元素时,很明显List最后一个元素为空,那么这时modCount就会告诉迭代器,让其抛出异常ConcurrentModificationException<br>&emsp;&emsp;如果没有这一个变量,那么系统会报异常ArrayIndexOutOfBoundsException,这样的异常显然不是应该出现的(这些运行时错误都是使用者的逻辑错误导致的,我们的JDK那么高端,不会出现使用错误,我们只抛出使用者造成的错误,而这个错误是设计者应该考虑的),为了避免出现这样的异常,定义了检查<br>&emsp;&emsp;详见:<a href="https://www.zhihu.com/question/24086463/answer/64717159" target="_blank" rel="noopener">https://www.zhihu.com/question/24086463/answer/64717159</a></p>
<h2 id="五、核心函数分析"><a href="#五、核心函数分析" class="headerlink" title="五、核心函数分析"></a>五、核心函数分析</h2><h3 id="1-indexOf"><a href="#1-indexOf" class="headerlink" title="1.indexOf"></a>1.indexOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序查找,返回元素的最低索引值(首先出现的索引位置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在 ? 最低索引值 : -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意:元素为null不是非法操作,空值也可以作为元素放入ArrayList</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//顺序查找数组缓冲区,注意:Arrays工具类提供了二分搜索,但没有提供顺序查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elementData[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-lastIndexOf"><a href="#2-lastIndexOf" class="headerlink" title="2.lastIndexOf"></a>2.lastIndexOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向查找(从数组末尾向开始查找),返回元素的最高索引值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在 ? 最高索引值 : -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elementData[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-clone"><a href="#3-clone" class="headerlink" title="3.clone"></a>3.clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度复制:对拷贝出来的ArrayList对象操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个克隆的ArrayList实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Object克隆方法:会复制对象及其内所有基本类型成员和String类型,但不会复制对象成员、引用对象</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//对需要复制的引用变量,进行独立的拷贝,将存储的元素移入新的ArrayList</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-toArray"><a href="#4-toArray" class="headerlink" title="4.toArray"></a>4.toArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回ArrayList的Object数组</span></span><br><span class="line"><span class="comment"> * - 包含ArrayList的所有存储元素</span></span><br><span class="line"><span class="comment"> * - 对返回的该数组进行操作,不会影响该ArrayList(相当于分配了一个新的数组) ==&gt; 该操作是安全的</span></span><br><span class="line"><span class="comment"> * - 元素存储顺序与ArrayList中的一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回ArrayList元素组成的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 需要存储list中元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 若a.length &gt;= list.size</span></span><br><span class="line"><span class="comment"> *          则将list中的元素按顺序存入a中,然后a[list.size]=null,a[list.size+1]及其之后的元素依旧是a的元素</span></span><br><span class="line"><span class="comment"> *          注意:若a中本类存储有元素,则a会被list的元素覆盖,且a[list.size]=null</span></span><br><span class="line"><span class="comment"> *         否则将返回包含list所有元素且数组长度等于list中元素个数的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 当a.getClass()!=list时,存储元素的类型时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 当a为null时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 若数组a的大小 &lt; ArrayList的元素个数,则新建一个数组,</span></span><br><span class="line">    <span class="comment">// 数组大小是ArrayList的元素个数,并将ArrayList全部拷贝到新数组中</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size) &#123;</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若a数组大小 &gt;= ArrayList的元素个数,则将ArrayList全部元素都拷贝到数组a中</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size) &#123;</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-add方法-重点"><a href="#5-add方法-重点" class="headerlink" title="5.add方法(重点)"></a>5.add方法(重点)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加新值到list末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定ArrayList的容量大小(严谨)</span></span><br><span class="line">    <span class="comment">// 注意；size+1 保证资源空间不被浪费,按当前情况,保证存多少元素就只分配多少空间资源</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 添加e到ArrayList中,然后size自增1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入方法:命名为insert()比较合理</span></span><br><span class="line"><span class="comment"> * - 在指定位置插入新元素,原先在index位置的值往后移动一位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要插入的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">            size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:正常情况下会扩容1.5倍,特殊情况下</p>
<ol>
<li>指定为空数组时为0  </li>
<li>新扩展数组大小已经达到了最大值则只取最大值<br>当我们调用add方法时,实际上的函数调用如下:<br><img alt="add流程" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81/ArrayList/add%E6%B5%81%E7%A8%8B.png?raw=true" class="lazyload"><br>说明:程序调用add实际上进行一系列调用,可能会调用grow,grow可能会调用hugeCapacity</li>
</ol>
<h4 id="5-1无参构造时add运行"><a href="#5-1无参构造时add运行" class="headerlink" title="5.1无参构造时add运行"></a>5.1无参构造时add运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">lists.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>说明:初始化list大小为0,调用ArrayList()型构造函数,那么在调用list.add()方法时是怎样的?<br><img alt="无参构造add" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81/ArrayList/%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0add.png?raw=true" class="lazyload"><br>在add方法之前开始elementData = {};调用add方法时会继续调用,直至grow,最后elementData的大小变为10，之后再返回到add函数，把8放在elementData[0]中</p>
<h4 id="5-2有参构造add运行"><a href="#5-2有参构造add运行" class="headerlink" title="5.2有参构造add运行"></a>5.2有参构造add运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">lists.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p><img alt="有参构造add" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81/ArrayList/%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0add.png?raw=true" class="lazyload"><br>在调用add方法之前,elementData的大小已经为6,之后再进行传递,不会进行扩容处理</p>
<h3 id="6-trimToSize"><a href="#6-trimToSize" class="headerlink" title="6.trimToSize()"></a>6.trimToSize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组缓冲区大小调整为实际ArrayList存储元素的大小</span></span><br><span class="line"><span class="comment"> * 即elementData = Arrays.copy(elementData, size)</span></span><br><span class="line"><span class="comment"> * 该方法由用户手动调用,以减少空间资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//modCount 是 AbstractList 的属性值: protected transient int modCount = 0;</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当实际大小 &lt; 数组缓冲区大小时(如调用默认构造函数后,刚添加一个元素时,此时elementData.length = 10,而size = 1)</span></span><br><span class="line">    <span class="comment">//通过这一步,可以使得空间得到有效利用,而不会出现资源浪费的情况</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">//注意此处的运算符优先级:先判断后把数组赋给elementData</span></span><br><span class="line">        <span class="comment">//调整数组缓冲区elementData变为实际存储大小</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">                ? EMPTY_ELEMENTDATA</span><br><span class="line">                : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将ArrayList容量设置为当前size大小,首先需要明确一个概念,ArrayList的size就是ArrayList的元素个数,length是ArrayList申请的内容空间长度.ArrayList每次都会预申请多一点空间,以便添加元素的时候不需要每次都进行扩容操作,例如我们的元素个数是10个,它申请的内存空间必定会大于10,即length&gt;size,而这个方法就是把ArrayList的内存空间设置为size,去除没有用到的null值空间.这也就是我们为什么每次在获取数据长度是都是调用list.size()而不是list.length()</p>
<h3 id="7-removeAll和retainAll-重点"><a href="#7-removeAll和retainAll-重点" class="headerlink" title="7.removeAll和retainAll(重点)"></a>7.removeAll和retainAll(重点)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除list和c中共有的元素</span></span><br><span class="line"><span class="comment"> * - 若实例化Collection的类不是ArrayList,则删除肯定失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 若list和c有公有元素,删除成功(list元素个数有改变):没有公有元素,删除失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 当c中元素和list的元素类型不兼容时</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 当c为null时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只保留list和集合c中公有的元素:和 removeAll()功能相反</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; list元素个数有改变</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在实际开发中removeAll这个动作很耗时,因为在bacthRemove需要循环原来的list,此时还会调用contains方法,而在contains方法中的indexOf方法又会循环一次,即removeAll两层for循环,复杂度O(m*n),所以在操作比较大的ArrayList时这种方法绝对不可取,可以采用下面的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">removeAll</span><span class="params">(List&lt;Integer&gt; src, List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;(src); <span class="comment">//大集合用linkedlist </span></span><br><span class="line"> 	HashSet&lt;Integer&gt; targetHash = <span class="keyword">new</span> HashSet&lt;&gt;(target); <span class="comment">//小集合用hashset </span></span><br><span class="line"></span><br><span class="line"> 	Iterator&lt;Integer&gt; iter = result.iterator(); <span class="comment">//采用Iterator迭代器进行数据的操作  </span></span><br><span class="line"> 	<span class="keyword">while</span>(iter.hasNext())&#123;  </span><br><span class="line"> 		<span class="keyword">if</span>(targetHash.contains(iter.next()))&#123;  </span><br><span class="line"> 			iter.remove(); </span><br><span class="line"> 		&#125; </span><br><span class="line"> 	&#125; </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1比较两种removeAll"><a href="#7-1比较两种removeAll" class="headerlink" title="7.1比较两种removeAll"></a>7.1比较两种removeAll</h4><ol>
<li>外层循环<br>一个是普通的for循环,一个迭代遍历元素,两者相差不大</li>
<li>内层数据比较<br>前者通过index方法把整个数组遍历了一遍<br>后者调用HashSet的Contains方法,实际上是调用HashMap的containKey方法,查找时是通过hash表查找,复杂度为O(1)</li>
</ol>
<h4 id="7-2Hash表简单介绍"><a href="#7-2Hash表简单介绍" class="headerlink" title="7.2Hash表简单介绍"></a>7.2Hash表简单介绍</h4><p>&emsp;&emsp;Hash表是一种特殊的数据结构,它同数组、链表以及二叉排序树等相比较有很明显的区别,它能够快速定位到想要查找的记录,而不是与表中存在的记录关键字进行比较来查找,这个源于Hash表设计的特殊性,它采用函数映射思想将记录的存储位置与记录的关键字关联起来,从而能够快速进行查找,可以简单理解为，以空间换时间，牺牲空间复杂度来换取时间复杂度<br>&emsp;&emsp;hash表采用一个映射函数f:key—&gt;address将关键字映射到该记录在标识的存储位置,从而在想要查找该记录时可以直接根据关键字和映射关系计算出该记录在表中的存储位置,通常情况下这个映射关系称作为hash函数,而通过hash函数合关键字计算出来的存储位置称作为hash地址(这里的存储位置只是表中的存储位置并不是实际的物理地址)<br><img alt="hash表" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81/ArrayList/hash%E8%A1%A8.png?raw=true" class="lazyload"><br>&emsp;&emsp;上图是hash表一种实现方式,是由数组+链表组成的,元素放入hash表的位置通过hash(key)%len获得即元素key的哈希值对数组长度取模得到的<br>&emsp;&emsp;另外hash表大小的确定也很关键,如果hash表的空间远远大于最后实际存储的记录个数,则造成了很大的空间浪费,如果选取小了的话则容易造成冲突.在实际情况中一般需要根据最终记录存储个数和关键字的分布特点来确定hash大小,还有一种情况可能事先不知道最终需要存储的记录个数,则需要动态维护hash表的容量,此时可能重新计算hash地址</p>
<h3 id="8-遍历ArrayList的对象iterator"><a href="#8-遍历ArrayList的对象iterator" class="headerlink" title="8.遍历ArrayList的对象iterator"></a>8.遍历ArrayList的对象iterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表指定位置开始返回列表迭代器(按顺序)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 元素的索引位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个ListIterator迭代器,该迭代器是fail-fast机制的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个Iterator迭代器,该迭代器是fail-fast机制的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterator方法是Abstract中实现的,该方法返回AbstractList一个内部类Itr对象</p>
<h3 id="9-subList"><a href="#9-subList" class="headerlink" title="9.subList"></a>9.subList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取从fromIndex到toIndex之间的子集合(左闭右开)</span></span><br><span class="line"><span class="comment"> * - 若fromIndex==toIndex,则返回的空集合</span></span><br><span class="line"><span class="comment"> * - 对该子集合操作,会影响原有集合</span></span><br><span class="line"><span class="comment"> * - 当调用了subList()后,若对原有集合进行删除(删除subList中的首个元素)操作,会抛出ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> * - 该子集合支持索引的集合操作</span></span><br><span class="line"><span class="comment"> * 原因看SubList内部类的构造函数即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法性检查</span></span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList.SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、ArrayList的内部类"><a href="#六、ArrayList的内部类" class="headerlink" title="六、ArrayList的内部类"></a>六、ArrayList的内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-Itr"><a href="#1-Itr" class="headerlink" title="1.Itr"></a>1.Itr</h3><p>Itr实现了Iterator接口,同时重写了里面的hasNext()、next()、remove()、forEachRemaining等方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractList.Itr优化版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 下一个返回元素的索引,默认值为0</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引,若没有上一个元素则为-1.每次调用remove(),lastRet都会重置为-1</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有下一个元素的判断</span></span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 临时变量i,指向游标当前位置</span></span><br><span class="line">        <span class="comment">// 此处并没有让lastRet直接等于cursor进行操作</span></span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="comment">// 第一次检查i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="comment">// 第二次检查i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意这里的取值</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 移除元素</span></span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="comment">// 指针回移</span></span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            <span class="comment">// 注意此处: 上一元素指针重置为-1,因此lastRet不一定等于cursor-1</span></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jdk1.8进行函数式编程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 动作(让集合每一个元素都执行该动作)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-ListItr"><a href="#2-ListItr" class="headerlink" title="2.ListItr"></a>2.ListItr</h3><p>继承Itr,实现了ListIterator接口;<br>重写了hasPrevious()、nextIndex()、previousIndex()、previous()、set(E e)、add(E e)等方法<br>这也看出了Iterator和ListIterator的区别:</p>
<ul>
<li>ListIterator有add()方法,可以向List中添加对象,而Iterator不能</li>
<li>ListIterator和Iterator都有hasNext()和next()方法,可以实现顺序向后遍历.但是ListIterator有hasPrevious()和previous()方法,可以实现逆向(顺序向前)遍历.Iterator就不可以</li>
<li>ListIterator可以定位当前的索引位置,nextIndex()和previousIndex()可以实现.Iterator没有此功能</li>
<li>都可实现删除对象,但是ListIterator可以实现对象的修改,set()方法可以实现.Iterator仅能遍历,不能修改.因为ListIterator的这些功能,可以实现对LinkedList等List数据结构的操作</li>
</ul>
<h3 id="3-SubList"><a href="#3-SubList" class="headerlink" title="3.SubList"></a>3.SubList</h3><p>继承AbstractList,实现了RandomAccess接口,类内部实现了对子序列的增删改查等方法,同时也充分利用了内部类的优点,就是共享ArrayList的全局变量,例如检查器变量modCount，数组elementData等，所以SubList进行的增删改查操作都是对ArrayList的数组进行的，并没有创建新的数组</p>
<h3 id="4-ArrayListSpliterator"><a href="#4-ArrayListSpliterator" class="headerlink" title="4.ArrayListSpliterator"></a>4.ArrayListSpliterator</h3><h2 id="七、ArrayList源码全解析"><a href="#七、ArrayList源码全解析" class="headerlink" title="七、ArrayList源码全解析"></a>七、ArrayList源码全解析</h2><h2 id="八、ArrayList总结"><a href="#八、ArrayList总结" class="headerlink" title="八、ArrayList总结"></a>八、ArrayList总结</h2><ul>
<li>ArrayList基于数组实现,其内存储元素的数组为elementData,elementData声明为transient Object[] elementData;</li>
<li>ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的使用—这两个常量数组的使用场景不同,前者是用户通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时,后者是用户直接使用无参构造创建ArrayList时</li>
<li>ArrayList默认容量为10,调用无参构造新建一个ArrayList时,其elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA,当第一次使用add()添加元素时,ArrayList的容量会为10</li>
<li>ArrayList的toArray()方法和subList()方法,在源数据和子数据之间的区别  </li>
</ul>
<p>&emsp;&emsp;toArray():对该方法返回的数组,进行操作(增删改查)都不会影响源数据(ArrayList中的elementData).二者是不会相互影响的<br>&emsp;&emsp;subList():对返回的子集合进行操作(增删改查)都会影响父集合.而且若是对父集合中进行删除操作(仅仅在删除子集合的首个元素)时,会抛出异常 ConcurrentModificationException</p>
<h2 id="九、c-toArray的官方bug"><a href="#九、c-toArray的官方bug" class="headerlink" title="九、c.toArray的官方bug"></a>九、c.toArray的官方bug</h2><p>public Object[] toArray()返回的类型不一定就是Object[], 其类型取决于其返回的实际类型<br>原因是我们父类实例的具体类型,实际上是取决于new时的子类类型</p>
<h3 id="1-代码分析"><a href="#1-代码分析" class="headerlink" title="1.代码分析"></a>1.代码分析</h3><h4 id="1-1创建类"><a href="#1-1创建类" class="headerlink" title="1.1创建类"></a>1.1创建类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2测试1"><a href="#1-2测试1" class="headerlink" title="1.2测试1"></a>1.2测试1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son[] sons = &#123;<span class="keyword">new</span> Son(), <span class="keyword">new</span> Son()&#125;;</span><br><span class="line">    System.out.println(sons.getClass());<span class="comment">// class [Lcom.johnnie.test.Test$Son</span></span><br><span class="line"></span><br><span class="line">    Father[] fathers = sons;</span><br><span class="line">    System.out.println(fathers.getClass());<span class="comment">// class [Lcom.johnnie.test.Test$Son</span></span><br><span class="line"></span><br><span class="line">    fathers[<span class="number">0</span>] = <span class="keyword">new</span> Father();<span class="comment">// java.lang.ArrayStoreException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于fathers[0] = new Father(); 这句话,为什么会报错?<br>&emsp;&emsp;报错原因是因为fathers实际类型是Son[],由于数组中元素类型是son类型,因而会出现向下转型异常.也就是说假如我们有1个Object[]数组,并不代表着我们可以将Object对象存进去,这取决于数组中元素实际的类型</p>
<h4 id="1-3测试2"><a href="#1-3测试2" class="headerlink" title="1.3测试2"></a>1.3测试2</h4><p>新建一个MyList,该类继承ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ss = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ss.add(<span class="string">"123"</span>);</span><br><span class="line">    Object[] objs = ss.toArray();<span class="comment">// LinkedList toArray()返回的本身就是Object</span></span><br><span class="line">    objs[<span class="number">0</span>] = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    ss = <span class="keyword">new</span> MyList&lt;&gt;();</span><br><span class="line">    objs = ss.toArray(); </span><br><span class="line">    System.out.println(objs.getClass()); <span class="comment">// class [Ljava.lang.String</span></span><br><span class="line">    objs[<span class="number">0</span>] = <span class="keyword">new</span> Object(); <span class="comment">// java.lang.ArrayStoreException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当我们调用List的toArray()时,我们实际调用的是其具体实现类MyList中重写的String[] toArray()方法.因此数组并不是Object[]而是String[],而向下转型是不安全的,因此会抛出异常<br>通过分析这个官方bug,我们就记住了:</p>
<ol>
<li>抽象类(接口)其具体类型,取决于实例化时所采用的导出类的类型</li>
<li>子类实现和父类同名方法,当返回值不一致时,默认调用的是子类的实现方法;如MyList中的String[] toArray</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合    </a><a class="post-meta__tags" href="/tags/ArrayList/">ArrayList    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?book" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?program" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>HashMap源码解析</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/04-ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?program" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>04-ThreadPoolExecutor源码分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/03-集合篇/Fail-Fast机制/" title="fail-fast机制"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?fail"><div class="relatedPosts_title">fail-fast机制</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/03-集合篇/集合工具类/" title="集合工具类"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?collect"><div class="relatedPosts_title">集合工具类</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/03-集合篇/TreeMap源码解析/" title="TreeMap源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?github"><div class="relatedPosts_title">TreeMap源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/03-集合篇/LinkedList源码解析/" title="LinkedList源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?document"><div class="relatedPosts_title">LinkedList源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/03-集合篇/HashMap源码解析/" title="HashMap源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?program"><div class="relatedPosts_title">HashMap源码解析</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>