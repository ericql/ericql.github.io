<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>String面试题解析 | Eric Liang</title><meta name="description" content="String面试题解析"><meta name="keywords" content="基础知识点,String"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="String面试题解析"><meta name="twitter:description" content="String面试题解析"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?interview"><meta property="og:type" content="article"><meta property="og:title" content="String面试题解析"><meta property="og:url" content="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="String面试题解析"><meta property="og:image" content="https://source.unsplash.com/300x300/?interview"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"><link rel="prev" title="String知识点梳理" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"><link rel="next" title="04-ThreadPoolExecutor源码分析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/04-ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#String面试题解析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">String面试题解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#字面量和运行时常量池"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">字面量和运行时常量池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#new-String创建了几个对象"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">new String创建了几个对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#运行时常量池的动态扩展"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">运行时常量池的动态扩展</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#intern的正确用法"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">intern的正确用法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#String创建是双引号还是构造函数"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">String创建是双引号还是构造函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#双引号-vs-构造函数"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">双引号 vs 构造函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#运行时字符串驻留"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">运行时字符串驻留</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#String面试题解析"><span class="toc-number">1.</span> <span class="toc-text">String面试题解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字面量和运行时常量池"><span class="toc-number">2.</span> <span class="toc-text">字面量和运行时常量池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new-String创建了几个对象"><span class="toc-number">3.</span> <span class="toc-text">new String创建了几个对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池的动态扩展"><span class="toc-number">3.1.</span> <span class="toc-text">运行时常量池的动态扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#intern的正确用法"><span class="toc-number">4.</span> <span class="toc-text">intern的正确用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String创建是双引号还是构造函数"><span class="toc-number">5.</span> <span class="toc-text">String创建是双引号还是构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双引号-vs-构造函数"><span class="toc-number">5.1.</span> <span class="toc-text">双引号 vs 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时字符串驻留"><span class="toc-number">5.2.</span> <span class="toc-text">运行时字符串驻留</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">String面试题解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-04</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/">01-Java基础篇</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">01-基础知识点</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="String面试题解析"><a href="#String面试题解析" class="headerlink" title="String面试题解析"></a>String面试题解析</h1><p>String，是Java中除了基本数据类型以外，最为重要的一个类型了。很多人会认为他比较简单。但是和String有关的面试题有很多，下面我随便找两道面试题，看看你能不能都答对：</p>
<ul>
<li>Q1：String s = new String(“hollis”);定义了几个对象</li>
<li>Q2：如何理解String的intern方法？</li>
</ul>
<p>上面这两个是面试题和String相关的比较常考的，很多人一般都知道答案</p>
<p>A1：若常量池中已经存在”hollis”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存在”hollis”，则先创建后引用，也就是有两个。</p>
<p>A2：当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p>
<p>两个答案看上去没有任何问题，但是，仔细想想好像哪里不对呀。按照上面的两个面试题的回答，就是说new String也会检查常量池，如果有的话就直接引用，如果不存在就要在常量池创建一个，那么还要intern干啥？难道以下代码是没有意义的吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;Hollis&quot;).intern();</span><br></pre></td></tr></table></figure>
<p>如果，每当我们使用new创建字符串的时候，都会到字符串池检查，然后返回。那么以下代码也应该输出结果都是true?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;Hollis&quot;;</span><br><span class="line">String s2 = new String(&quot;Hollis&quot;);</span><br><span class="line">String s3 = new String(&quot;Hollis&quot;).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>
<p>但是，以上代码输出结果为（base jdk1.8.0_73）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h1 id="字面量和运行时常量池"><a href="#字面量和运行时常量池" class="headerlink" title="字面量和运行时常量池"></a>字面量和运行时常量池</h1><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p>
<p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储<strong>编译期</strong>生成的各种<strong>字面量和符号引用</strong></p>
<p>了解Class文件结构或者做过Java代码的<a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>的朋友可能都知道，在java代码被javac编译之后，文件结构中是包含一部分<font color="red">Constant pool</font>的。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"Hollis"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过编译后，常量池内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #21            // Hollis</span><br><span class="line">   #3 = Class              #22            // StringDemo</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   ...</span><br><span class="line">   #16 = Utf8               s</span><br><span class="line">   ..</span><br><span class="line">   #21 = Utf8               Hollis</span><br><span class="line">   #22 = Utf8               StringDemo</span><br><span class="line">   #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>
<p>上面的Class文件中的常量池中，比较重要的几个内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               Hollis</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure>
<p>上面几个常量中，<font color="red">s</font>就是前面提到的<strong>符号引用</strong>，而<font color="red">Hollis</font>就是前面提到的<strong>字面量</strong>。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去</p>
<h1 id="new-String创建了几个对象"><a href="#new-String创建了几个对象" class="headerlink" title="new String创建了几个对象"></a>new String创建了几个对象</h1><p>下面，我们可以来分析下<font color="red">String s = new String(“Hollis”);</font>创建对象情况了</p>
<p>这段代码中，我们可以知道的是，在编译期，<strong>符号引用</strong>s和<strong>字面量</strong>Hollis会被加入到Class文件的常量池中，然后在类加载阶段（具体时间段参考Java 中<a href="https://www.zhihu.com/question/55994121" target="_blank" rel="noopener">new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的?</a>），这两个常量会进入常量池</p>
<p>但是，这个“进入”阶段，并不会直接把所有类中定义的常量全部都加载进来，而是会做个比较，如果需要加到字符串常量池中的字符串已经存在，那么就不需要再把字符串字面量加载进来了</p>
<p>所以，当我们说&lt;若常量池中已经存在”hollis”，则直接引用，也就是此时只会创建一个对象&gt;说的就是这个字符串字面量在字符串池中被创建的过程</p>
<p>说完了编译期的事儿了，该到运行期了，在运行期，<font color="red">new String(“Hollis”);</font>执行到的时候，是要在Java堆中创建一个字符串对象的，而这个对象所对应的字符串字面量是保存在字符串常量池中的。但是，<font color="red">String s = new String(“Hollis”);</font>，<strong>对象的符号引用s是保存在Java虚拟机栈上的，他保存的是堆中刚刚创建出来的的字符串对象的引用</strong></p>
<p>所以，你也就知道以下代码输出结果为false的原因了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;Hollis&quot;);</span><br><span class="line">String s2 = new String(&quot;Hollis&quot;);</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>因为，<font color="red">==</font>比较的是<font color="red">s1</font>和<font color="red">s2</font>在堆中创建的对象的地址，当然不同了。但是如果使用<font color="red">equals</font>，那么比较的就是字面量的内容了，那就会得到<font color="red">true</font><br><img alt="两个堆对象的比较" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/string12%E5%A0%86%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83.png?raw=true" class="lazyload"></p>
<blockquote>
<p>在不同版本的JDK中，Java堆和字符串常量池之间的关系也是不同的，这里为了方便表述，就画成两个独立的物理区域了。具体情况请参考Java虚拟机规范</p>
</blockquote>
<p><strong>常量池中的“对象”是在编译期就确定好了的，在类被加载的时候创建的，如果类加载时，该字符串常量在常量池中已经有了，那这一步就省略了。堆中的对象是在运行期才确定的，在代码执行到new的时候创建的</strong>  </p>
<h2 id="运行时常量池的动态扩展"><a href="#运行时常量池的动态扩展" class="headerlink" title="运行时常量池的动态扩展"></a>运行时常量池的动态扩展</h2><p><strong>编译期</strong>生成的各种<strong>字面量和符号引用</strong>是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是<font color="red">String的intern</font>方法</p>
<p>当一个<font color="red">String</font>实例调用<font color="red">intern()</font>方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用</p>
<p><strong>intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用</strong></p>
<p>我们再来看下开头的那个让人产生疑惑的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>
<p>你可以简单的理解为<font color="red">String s1 = “Hollis”;</font>和<font color="red">String s3 = new String(“Hollis”).intern();</font>做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用<br><img alt="intern与s1" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/intern%E4%B8%8Es1.png?raw=true" class="lazyload"></p>
<p>对于<font color="red">String s3 = new String(“Hollis”).intern();</font>，在不调用<font color="red">intern</font>情况，s3指向的是JVM在堆中创建的那个对象的引用的（如图中的s2）。但是当执行了<font color="red">intern</font>方法时，s3将指向字符串常量池中的那个字符串常量</p>
<p>由于s1和s3都是字符串常量池中的字面量的引用，所以s1==s3。但是，s2的引用是堆中的对象，所以s2!=s1</p>
<h1 id="intern的正确用法"><a href="#intern的正确用法" class="headerlink" title="intern的正确用法"></a>intern的正确用法</h1><p>不知道，你有没有发现，在<font color="red">String s3 = new String(“Hollis”).intern();</font>中，其实intern是多余的？</p>
<p>因为就算不用<font color="red">intern</font>，Hollis作为一个字面量也会被加载到Class文件的常量池，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才需要使用<font color="red">intern</font>呢？</p>
<p>在解释这个之前，我们先来看下以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="string">"Chuang"</span>;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = <span class="string">"Hollis"</span> + <span class="string">"Chuang"</span>;</span><br></pre></td></tr></table></figure>
<p>在经过反编译后，得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="string">"Chuang"</span>;</span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = <span class="string">"HollisChuang"</span>;</span><br></pre></td></tr></table></figure>
<p>可以发现，同样是字符串拼接，s3和s4在经过编译器编译后的实现方式并不一样。s3被转化成<font color="red">StringBuilder及append</font>，而s4被直接拼接成新的字符串</p>
<p>如果你感兴趣，你还能发现，<font color="red">String s3 = s1 + s2;</font> 经过编译之后，常量池中是有两个字符串常量的分别是 <font color="red">Hollis、Chuang</font>（其实Hollis和Chuang是String s1 = “Hollis”;和String s2 = “Chuang”;定义出来的），拼接结果<font color="red">HollisChuang</font>并不在常量池中</p>
<p>如果代码只有 <font color="red">String s4 = “Hollis” + “Chuang”;</font>，那么常量池中将只有HollisChuang而没有”Hollis” 和 “Chuang”</p>
<p>究其原因，是因为常量池要保存的是<strong>已确定的字面量值</strong>。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串池</p>
<p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成<font color="red">StringBuilder.append</font>，这种情况编译器是无法知道其确定值的。只有在运行期才能确定</p>
<p>那么，有了这个特性了，<font color="red">intern</font>就有用武之地了。那就是很多时候，我们在程序中得到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中</p>
<p>这时候，对于那种可能经常使用的字符串，使用intern进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了</p>
<p>如一<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a>文中举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer[] DB_DATA = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(<span class="number">10</span> * <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] = random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">         arr[i] = <span class="keyword">new</span> String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println((System.currentTimeMillis() - t) + <span class="string">"ms"</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们明确的知道，会有很多重复的相同的字符串产生，但是这些字符串的值都是只有在运行期才能确定的。所以，只能我们通过intern显示的将其加入常量池，这样可以减少很多字符串的重复创建  </p>
<h1 id="String创建是双引号还是构造函数"><a href="#String创建是双引号还是构造函数" class="headerlink" title="String创建是双引号还是构造函数"></a>String创建是双引号还是构造函数</h1><p>在Java中，有两种方式可以创建字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;abc&quot;;</span><br><span class="line">String y = new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>使用双引号和构造函数之间到底有什么区别呢？</p>
<h2 id="双引号-vs-构造函数"><a href="#双引号-vs-构造函数" class="headerlink" title="双引号 vs 构造函数"></a>双引号 vs 构造函数</h2><p>这个问题可以使用这两个简单代码实例来回答：</p>
<p>实例一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abcd&quot;;</span><br><span class="line">String b = &quot;abcd&quot;;</span><br><span class="line">System.out.println(&quot;a == b : &quot;+(a == b)); // true</span><br><span class="line">System.out.println(&quot;a.equals(b) : &quot;+(a.equals(b))); // true</span><br></pre></td></tr></table></figure>
<p><font color="red">a== b</font>等于<font color="red">true</font> 是因为x和y指向方法区中同一个字符串常量，他们的引用是相同的（==比较的是引用）</p>
<p>当相同的字符串常量被多次创建时，只会保存字符串常量的一份副本，这称为“字符串驻留”。在Java中，所有编译时字符串常量都是驻留的。</p>
<p>实例二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String c = new String(&quot;abcd&quot;);</span><br><span class="line">String d = new String(&quot;abcd&quot;);</span><br><span class="line">System.out.println(&quot;c == d : &quot;+(c == d)); // false</span><br><span class="line">System.out.println(&quot;c.equals(d) : &quot;+(c.equals(d))); // true</span><br></pre></td></tr></table></figure>
<p><font color="red">c== d</font>等于<font color="red">false</font> 是因为c和d指向堆中不同的对象。不同的对象拥有不同的内存引用</p>
<p>下面图论证了以上的结论<br><img alt="引号与new字符串" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/%E5%BC%95%E5%8F%B7%E4%B8%8Enew%E5%AD%97%E7%AC%A6%E4%B8%B2.png?raw=true" class="lazyload"></p>
<h2 id="运行时字符串驻留"><a href="#运行时字符串驻留" class="headerlink" title="运行时字符串驻留"></a>运行时字符串驻留</h2><p>运行时也会发生字符串驻留，即使两个字符串是由构造函数方法创建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String c = new String(&quot;abcd&quot;).intern();</span><br><span class="line">String d = new String(&quot;abcd&quot;).intern();</span><br><span class="line">System.out.println(&quot;c == d : &quot;+(c == d)); // true</span><br><span class="line">System.out.println(&quot;c.equals(d) : &quot;+(c.equals(d))); // true    （JDK1.7）</span><br></pre></td></tr></table></figure>
<p>因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。</p>
<p>因此，<strong>如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式</strong></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/">https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">基础知识点    </a><a class="post-meta__tags" href="/tags/String/">String    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?interview" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/String/String%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?knowledge" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>String知识点梳理</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/04-ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?program" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>04-ThreadPoolExecutor源码分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/01-基础知识点/String/String知识点梳理/" title="String知识点梳理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?knowledge"><div class="relatedPosts_title">String知识点梳理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/01-基础知识点/String/StringUtils解析/" title="StringUtils解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?string"><div class="relatedPosts_title">StringUtils解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/01-基础知识点/Java中的equals()和hashcode()之间关系/" title="Java中的equals()和hashcode()之间关系"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?equals"><div class="relatedPosts_title">Java中的equals()和hashcode()之间关系</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/01-基础知识点/ThreadLocal/ThreadLocal示例与原理/" title="ThreadLocal示例与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?thread"><div class="relatedPosts_title">ThreadLocal示例与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/01-基础知识点/ThreadLocal/增强版的ThreadLocal----TransmittableThreadLocal/" title="增强版的ThreadLocal----TransmittableThreadLocal"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?enhance"><div class="relatedPosts_title">增强版的ThreadLocal----TransmittableThreadLocal</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/01-Java基础篇/02-JDK源码篇/String源码解析/" title="String源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">String源码解析</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>