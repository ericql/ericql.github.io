<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>17-Executor框架 | Eric Liang</title><meta name="description" content="Executor框架"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="17-Executor框架"><meta name="twitter:description" content="Executor框架"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?exec"><meta property="og:type" content="article"><meta property="og:title" content="17-Executor框架"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/17-Executor%E6%A1%86%E6%9E%B6/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="Executor框架"><meta property="og:image" content="https://source.unsplash.com/300x300/?exec"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/17-Executor%E6%A1%86%E6%9E%B6/"><link rel="prev" title="Java并发编程基础" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/01-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><link rel="next" title="01-Thread源码解析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/01-Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Executor框架"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Executor框架</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Executor框架简介"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Executor框架简介</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Executor框架的两级调度模型"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">Executor框架的两级调度模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Executor框架的结构与成员"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">Executor框架的结构与成员</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Executor框架的结构"><span class="toc_mobile_items-number">1.1.2.1.</span> <span class="toc_mobile_items-text">Executor框架的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Executor框架的成员"><span class="toc_mobile_items-number">1.1.2.2.</span> <span class="toc_mobile_items-text">Executor框架的成员</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#ThreadPoolExecutor"><span class="toc_mobile_items-number">1.1.2.2.1.</span> <span class="toc_mobile_items-text">ThreadPoolExecutor</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#ScheduledThreadPoolExecutor"><span class="toc_mobile_items-number">1.1.2.2.2.</span> <span class="toc_mobile_items-text">ScheduledThreadPoolExecutor</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#Future接口"><span class="toc_mobile_items-number">1.1.2.2.3.</span> <span class="toc_mobile_items-text">Future接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#Runnable接口和Callable接口"><span class="toc_mobile_items-number">1.1.2.2.4.</span> <span class="toc_mobile_items-text">Runnable接口和Callable接口</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ThreadPoolExecutor详解"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">ThreadPoolExecutor详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FixedThreadPool详解"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">FixedThreadPool详解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SingleThreadExecutor详解"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">SingleThreadExecutor详解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CachedThreadPool详解"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">CachedThreadPool详解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ScheduledThreadPoolExecutor详解"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">ScheduledThreadPoolExecutor详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ScheduledThreadPoolExecutor的运行机制"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">ScheduledThreadPoolExecutor的运行机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ScheduledThreadPoolExecutor的实现"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">ScheduledThreadPoolExecutor的实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#FutureTask详解"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">FutureTask详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FutureTask简介"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">FutureTask简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FutureTask的使用"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">FutureTask的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FutureTask的实现"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">FutureTask的实现</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Executor框架"><span class="toc-number">1.</span> <span class="toc-text">Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor框架简介"><span class="toc-number">1.1.</span> <span class="toc-text">Executor框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor框架的两级调度模型"><span class="toc-number">1.1.1.</span> <span class="toc-text">Executor框架的两级调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor框架的结构与成员"><span class="toc-number">1.1.2.</span> <span class="toc-text">Executor框架的结构与成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor框架的结构"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Executor框架的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor框架的成员"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Executor框架的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ScheduledThreadPoolExecutor"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">ScheduledThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future接口"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Runnable接口和Callable接口"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">Runnable接口和Callable接口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor详解"><span class="toc-number">1.2.</span> <span class="toc-text">ThreadPoolExecutor详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FixedThreadPool详解"><span class="toc-number">1.2.1.</span> <span class="toc-text">FixedThreadPool详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleThreadExecutor详解"><span class="toc-number">1.2.2.</span> <span class="toc-text">SingleThreadExecutor详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CachedThreadPool详解"><span class="toc-number">1.2.3.</span> <span class="toc-text">CachedThreadPool详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScheduledThreadPoolExecutor详解"><span class="toc-number">1.3.</span> <span class="toc-text">ScheduledThreadPoolExecutor详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPoolExecutor的运行机制"><span class="toc-number">1.3.1.</span> <span class="toc-text">ScheduledThreadPoolExecutor的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPoolExecutor的实现"><span class="toc-number">1.3.2.</span> <span class="toc-text">ScheduledThreadPoolExecutor的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FutureTask详解"><span class="toc-number">1.4.</span> <span class="toc-text">FutureTask详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask简介"><span class="toc-number">1.4.1.</span> <span class="toc-text">FutureTask简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask的使用"><span class="toc-number">1.4.2.</span> <span class="toc-text">FutureTask的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask的实现"><span class="toc-number">1.4.3.</span> <span class="toc-text">FutureTask的实现</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">17-Executor框架</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-05</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/">01-应用篇</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p>&emsp;&emsp;在Java中,使用线程来异步执行任务.Java线程的创建与销毁需要一定的开销,如果我们为每一个任务创建一个新线程来执行,这些线程的创建与销毁将消耗大量的计算资源.同时,为每一个任务创建一个新线程来执行,这种策略可能会使处于高负荷状态的应用最终崩溃<br>&emsp;&emsp;Java的线程既是工作单元,也是执行机制.从JDK 5开始,把工作单元与执行机制分离开来.工作单元包括Runnable和Callable，而执行机制由Executor框架提供</p>
<h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>&emsp;&emsp;在HotSpot VM的线程模型中,Java线程(java.lang.Thread)被一对一映射为本地操作系统线程.Java线程启动时会创建一个本地操作系统线程;当该Java线程终止时,这个操作系统线程也会被回收.操作系统会调度所有线程并将它们分配给可用的CPU<br>&emsp;&emsp;在上层,Java多线程程序通常把应用分解为若干个任务,然后使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程;在底层,操作系统内核将这些线程映射到硬件处理器上.这种两级调度模型的示意图如下：<br><img alt="任务的两级调度模型.jpg" data-src="https://upload.cc/i1/2020/01/12/bkC9lZ.jpg" class="lazyload"><br>&emsp;&emsp;从图中可以看出,应用程序通过Executor框架控制上层的调度;而下层的调度由操作系统内核控制,下层的调度不受应用程序的控制</p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><p>本文将分两部分来介绍Executor：Executor的结构和Executor框架包含的成员组件</p>
<h4 id="Executor框架的结构"><a href="#Executor框架的结构" class="headerlink" title="Executor框架的结构"></a>Executor框架的结构</h4><p>Executor框架主要由3大部分组成如下:</p>
<ul>
<li>任务：包括被执行任务需要实现的接口(Runnable接口或Callable接口)</li>
<li>任务的执行：包括任务执行机制的核心接口Executor,以及继承自Executor的ExecutorService接口.Executor框架有两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor)</li>
<li>异步计算的结果：包括接口Future和实现Future接口的FutureTask类</li>
</ul>
<p>Executor框架包含的主要的类与接口如下图:<br><img alt="Executor类结构图.png" data-src="https://upload.cc/i1/2020/01/12/u7FJ4t.png" class="lazyload"><br><img alt="Future类结构图.png" data-src="https://upload.cc/i1/2020/01/12/pbTzI6.png" class="lazyload"></p>
<p>类和接口的简介:</p>
<ul>
<li>Executor是一个接口,它是Executor框架的基础,它将任务的提交与任务的执行分离开来</li>
<li>ThreadPoolExecutor是线程池的核心实现类,用来执行被提交的任务</li>
<li>ScheduledThreadPoolExecutor是一个实现类,可以在给定的延迟后运行命令,或者定期执行命令.ScheduledThreadPoolExecutor比Timer更灵活,功能更强大</li>
<li>Future接口和实现Future接口的FutureTask类,代表异步计算的结果</li>
<li>Runnable接口和Callable接口的实现类,都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行</li>
</ul>
<p>Executor框架的使用示意图如下：<br><img alt="Executor框架的使用示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/QxZ7uT.jpg" class="lazyload"></p>
<ul>
<li>主线程首先要创建实现Runnable或者Callable接口的任务对象.工具类Executors可以把一个Runnable对象封装为一个Callable对象(Executors.callable(Runnable task)或Executors.callable(Runnable task，Object resule))</li>
<li>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runnable command));或者也可以把Runnable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit(Callable<t>task))</t></li>
<li>如果执行ExecutorService.submit(…),ExecutorService将返回一个实现Future接口的对象(到目前为止的JDK中,返回的是FutureTask对象).由于FutureTask实现了Runnable,程序员也可以创建FutureTask,然后直接交给ExecutorService执行</li>
<li>最后,主线程可以执行FutureTask.get()方法来等待任务执行完成.主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行</li>
</ul>
<h4 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h4><p>&emsp;&emsp;Executor框架的主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors  </p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>&emsp;&emsp;ThreadPoolExecutor通常使用工厂类Executors来创建.Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool  </p>
<ol>
<li>FixedThreadPool<br>下面是Executors提供的,创建使用固定线程数的FixedThreadPool的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
FixedThreadPool适用于为了满足资源管理的需求,而需要限制当前线程数量的应用场景,它适用于负载比较重的服务器</li>
<li>SingleThreadExecutor<br>下面是Executors提供的,创建使用单个线程的SingleThreadExecutor的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
SingleThreadExecutor适用于需要保证顺序地执行各个任务;并且在任意时间点,不会有多个线程是活动的应用场景</li>
<li>CachedThreadPool<br>下面是Executors提供的,创建一个会根据需要创建新线程的CachedThreadPool的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
CachedThreadPool是大小无界的线程池,适用于执行很多的短期异步任务的小程序,或者是负载较轻的服务器</li>
</ol>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建.Executors可以创建2种类型的ScheduledThreadPoolExecutor,如下:</p>
<ul>
<li>ScheduledThreadPoolExecutor：包含若干个线程的ScheduledThreadPoolExecutor</li>
<li>SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor</li>
</ul>
<ol>
<li>固定个数ScheduledThreadPoolExecutor<br>下面是工厂类Executors提供的,创建固定个数线程的ScheduledThreadPoolExecutor的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function">ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务,同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</li>
<li>SingleThreadScheduledExecutor<br>下面是Executors提供的,创建单个线程的SingleThreadScheduledExecutor的API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService newSingleThreadScheduledExecutor</span></span><br><span class="line"><span class="function"><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务,同时需要保证顺序地执行各个任务的应用场景</li>
</ol>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p>&emsp;&emsp;Future接口和实现Future接口的FutureTask类用来表示异步计算的结果.当我们把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时,ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象.下面是对应的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>到JDK 8为止,Java通过上述API返回的是一个FutureTask对象.但从API可以看到,Java仅仅保证返回的是一个实现了Future接口的对象.在将来的JDK实现中,返回的可能不一定是FutureTask</p>
</blockquote>
<h5 id="Runnable接口和Callable接口"><a href="#Runnable接口和Callable接口" class="headerlink" title="Runnable接口和Callable接口"></a>Runnable接口和Callable接口</h5><p>&emsp;&emsp;Runnable接口和Callable接口的实现类,都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行.它们之间的区别是Runnable不会返回结果,而Callable可以返回结果<br>&emsp;&emsp;除了可以自己创建实现Callable接口的对象外,还可以使用工厂类Executors来把一个Runnable包装成一个Callable  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure>
<p>当我们把一个Callable对象(比如上面的Callable1或Callable2)提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时,submit(…)会向我们返回一个FutureTask对象.我们可以执行FutureTask.get()方法来等待任务执行完成.当任务成功完成后FutureTask.get()将返回该任务的结果</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><p>&emsp;&emsp;Executor框架最核心的类是ThreadPoolExecutor,它是线程池的实现类,主要由下列4个组件构成</p>
<ul>
<li>corePool：核心线程池的大小</li>
<li>maximumPool：最大线程池的大小</li>
<li>BlockingQueue：用来暂时保存任务的工作队列</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时(达到了最大线程池大小且工作队列已满),execute()方法将要调用的Handler</li>
</ul>
<h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p>FixedThreadPool被称为可重用固定线程数的线程池.下面是FixedThreadPool的源代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads<br>&emsp;&emsp;当线程池中的线程数大于corePoolSize时,keepAliveTime为多余的空闲线程等待新任务的最长时间,超过这个时间后多余的线程将被终止.这里把keepAliveTime设置为0L,意味着多余的空闲线程会被立即终止<br>FixedThreadPool的execute()方法的运行示意图如下：<br><img alt="FixedThreadPool的execute()的运行示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/F5uJSO.jpg" class="lazyload"><br>说明如下：</p>
<ul>
<li>如果当前运行的线程数少于corePoolSize,则创建新线程来执行任务</li>
<li>在线程池完成预热之后(当前运行的线程数等于corePoolSize),将任务加入LinkedBlockingQueue</li>
<li>线程执行完1中的任务后,会在循环中反复从LinkedBlockingQueue获取任务来执行</li>
</ul>
<p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE).使用无界队列作为工作队列会对线程池带来如下影响:</p>
<ul>
<li>当线程池中的线程数达到corePoolSize后,新任务将在无界队列中等待,因此线程池中的线程数不会超过corePoolSize</li>
<li>由于1,使用无界队列时maximumPoolSize将是一个无效参数</li>
<li>由于1和2,使用无界队列时keepAliveTime将是一个无效参数</li>
<li>由于使用无界队列,运行中的FixedThreadPool(未执行方法shutdown()或shutdownNow())不会拒绝任务(不会调用RejectedExecutionHandler.rejectedExecution方法)</li>
</ul>
<h3 id="SingleThreadExecutor详解"><a href="#SingleThreadExecutor详解" class="headerlink" title="SingleThreadExecutor详解"></a>SingleThreadExecutor详解</h3><p>SingleThreadExecutor是使用单个worker线程的Executor.下面是SingleThreadExecutor的源代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1.其他参数与FixedThreadPool相同.SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列(队列的容量为Integer.MAX_VALUE).SingleThreadExecutor使用无界队列作为工作队列对线程池带来的影响与FixedThreadPool相同  </p>
<p>SingleThreadExecutor的运行示意图如下：<br><img alt="SingleThreadExecutor的execute()的运行示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/qaJGDy.jpg" class="lazyload"><br>说明如下：</p>
<ul>
<li>如果当前运行的线程数少于corePoolSize(即线程池中无运行的线程),则创建一个新线程来执行任务</li>
<li>在线程池完成预热之后(当前线程池中有一个运行的线程),将任务加入LinkedBlockingQueue</li>
<li>线程执行完1中的任务后,会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行</li>
</ul>
<h3 id="CachedThreadPool详解"><a href="#CachedThreadPool详解" class="headerlink" title="CachedThreadPool详解"></a>CachedThreadPool详解</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池.下面是创建CachedThreadPool的源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;CachedThreadPool的corePoolSize被设置为0,即corePool为空;maximumPoolSize被设置为Integer.MAX_VALUE,即maximumPool是无界的.这里把keepAliveTime设置为60L,意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒,空闲线程超过60秒后将会被终止<br>&emsp;&emsp;FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列.CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列,但CachedThreadPool的maximumPool是无界的.这意味着,如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时,CachedThreadPool会不断创建新线程.极端情况下,CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源  </p>
<p>CachedThreadPool的execute()方法的执行示意图如下：<br><img alt="CachedThreadPool的execute()的运行示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/pPRyHr.jpg" class="lazyload"><br>说明如下：</p>
<ul>
<li>首先执行SynchronousQueue.offer(Runnable task).如果当前maximumPool中有空闲线程正在执行SynchronousQueue.poll(keepAliveTime，TimeUnit.NANOSECONDS),那么主线程执行offer操作与空闲线程执行的poll操作配对成功,主线程把任务交给空闲线程执行,execute()方法执行完成;否则执行下面的步骤2</li>
<li>当初始maximumPool为空,或者maximumPool中当前没有空闲线程时,将没有线程执行SynchronousQueue.poll(keepAliveTime，TimeUnit.NANOSECONDS).这种情况下,步骤1)将失败.此时CachedThreadPool会创建一个新线程执行任务,execute()方法执行完成</li>
<li>在步骤2)中新创建的线程将任务执行完后,会执行SynchronousQueue.poll(keepAliveTime，TimeUnit.NANOSECONDS).这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟.如果60秒钟内主线程提交了一个新任务(主线程执行步骤1)),那么这个空闲线程将执行主线程提交的新任务;否则,这个空闲线程将终止.由于空闲60秒的空闲线程会被终止,因此长时间保持空闲的CachedThreadPool不会使用任何资源</li>
</ul>
<p>&emsp;&emsp;前面提到过,SynchronousQueue是一个没有容量的阻塞队列.每个插入操作必须等待另一个线程的对应移除操作,反之亦然.CachedThreadPool使用SynchronousQueue,把主线程提交的任务传递给空闲线程执行.CachedThreadPool中任务传递的示意图如下：<br><img alt="CachedThreadPool的任务传递示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/BF0aq3.jpg" class="lazyload"></p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>&emsp;&emsp;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor.它主要用来在给定的延迟之后运行任务或者定期执行任务.ScheduledThreadPoolExecutor的功能与Timer类似,但ScheduledThreadPoolExecutor功能更强大、更灵活.Timer对应的是单个后台线程,而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p>ScheduledThreadPoolExecutor的执行示意图如下：<br><img alt="ScheduledThreadPoolExecutor的任务传递示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/3xTKGD.jpg" class="lazyload"><br>DelayQueue是一个无界队列,所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义.ScheduledThreadPoolExecutor的执行主要分为两大部分:</p>
<ol>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时,会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFutur接口的ScheduledFutureTask</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask,然后执行任务</li>
</ol>
<p>ScheduledThreadPoolExecutor为了实现周期性的执行任务,对ThreadPoolExecutor做了如下的修改:</p>
<ul>
<li>使用DelayQueue作为任务队列</li>
<li>获取任务的方式不同</li>
<li>执行周期任务后,增加了额外的处理</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>&emsp;&emsp;ScheduledThreadPoolExecutor会把待调度的任务(ScheduledFutureTask)放到一个DelayQueue中;ScheduledFutureTask主要包含3个成员变量,如下:</p>
<ul>
<li>long型成员变量time：表示这个任务将要被执行的具体时间</li>
<li>long型成员变量sequenceNumber：表示这个任务被添加到ScheduledThreadPoolExecutor中的序号</li>
<li>long型成员变量period：表示任务执行的间隔周期</li>
</ul>
<p>&emsp;&emsp;DelayQueue封装了一个PriorityQueue,这个PriorityQueue会对队列中的ScheduledFutureTask进行排序.排序时,time小的排在前面(时间早的任务将被先执行).如果两个ScheduledFutureTask的time相同,就比较sequenceNumber,sequenceNumber小的排在前面(也就是说,如果两个任务的执行时间相同,那么先提交的任务将被先执行)  </p>
<p>ScheduledThreadPoolExecutor中的线程执行某个周期任务的4个步骤如下：<br><img alt="ScheduledThreadPoolExecutor的任务执行步骤.jpg" data-src="https://upload.cc/i1/2020/01/12/KO8vwc.jpg" class="lazyload"><br>这4个步骤的说明：</p>
<ol>
<li>线程1从DelayQueue中获取已到期的ScheduledFutureTask(DelayQueue.take()).到期任务是指ScheduledFutureTask的time大于等于当前时间</li>
<li>线程1执行这个ScheduledFutureTask</li>
<li>线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间</li>
<li>线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中(DelayQueue.add())</li>
</ol>
<p>步骤1获取任务的过程–DelayQueue.take()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取任务分为3大步骤：</p>
<ol>
<li>获取Lock</li>
<li>获取周期任务<ul>
<li>如果PriorityQueue为空,当前线程到Condition中等待;否则执行下面的2.2</li>
<li>如果PriorityQueue的头元素的time时间比当前时间大,到Condition中等待到time时间;否则执行下面的2.3</li>
<li>获取PriorityQueue的头元素(2.3.1);如果PriorityQueue不为空,则唤醒在Condition中等待的所有线程(2.3.2)</li>
</ul>
</li>
<li>释放Lock</li>
</ol>
<p>让我们看看ScheduledThreadPoolExecutor中的线程执行任务的步骤4,把ScheduledFutureTask放入DelayQueue中的过程.下面是DelayQueue.add()的源代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现Future接口的FutureTask类,代表异步计算的结果</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>&emsp;&emsp;FutureTask除了实现Future接口外,还实现了Runnable接口.因此,FutureTask可以交给Executor执行,也可以由调用线程直接执行(FutureTask.run()).根据FutureTask.run()方法被执行的时机,FutureTask可以处于下面3种状态:</p>
<ol>
<li>未启动：FutureTask.run()方法还没有被执行之前,FutureTask处于未启动状态.当创建一个FutureTask,且没有执行FutureTask.run()方法之前,这个FutureTask处于未启动状态</li>
<li>已启动：FutureTask.run()方法被执行的过程中,FutureTask处于已启动状态</li>
<li>已完成：FutureTask.run()方法执行完后正常结束,或被取消(FutureTask.cancel(…)),或执行FutureTask.run()方法时抛出异常而异常结束,FutureTask处于已完成状态</li>
</ol>
<p><img alt="FutureTask的状态迁移示意图.png" data-src="https://upload.cc/i1/2020/01/12/5TsVm6.png" class="lazyload"><br>&emsp;&emsp;当FutureTask处于未启动或已启动状态时,执行FutureTask.get()方法将导致调用线程阻塞;当FutureTask处于已完成状态时,执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常<br>&emsp;&emsp;当FutureTask处于未启动状态时,执行FutureTask.cancel()方法将导致此任务永远不会被执行;当FutureTask处于已启动状态时,执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务;当FutureTask处于已启动状态时,执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成);当FutureTask处于已完成状态时,执行FutureTask.cancel(…)方法将返回false<br><img alt="FutureTask的get和cancel的执行示意图.jpg" data-src="https://upload.cc/i1/2020/01/12/NGJZlC.jpg" class="lazyload"></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>&emsp;&emsp;可以把FutureTask交给Executor执行;也可以通过ExecutorService.submit(…)方法返回一个FutureTask,然后执行FutureTask.get()方法或FutureTask.cancel(…)方法.除此以外,还可以单独使用FutureTask<br>&emsp;&emsp;当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行,此时可以使用FutureTask.假设有多个线程执行若干任务,每个任务最多只能被执行一次.当多个线程试图同时执行同一个任务时,只允许一个线程执行任务,其他线程需要等待这个任务执行完后才能继续执行.下面是对应的示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">executionTask</span><span class="params">(<span class="keyword">final</span> String taskName)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1,2.1</span></span><br><span class="line">            Future&lt;String&gt; future = taskCache.get(taskName);</span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;String&gt; task = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> taskName;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(task);</span><br><span class="line">                future = taskCache.putIfAbsent(taskName, futureTask); <span class="comment">// 1.3</span></span><br><span class="line">                <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    future = futureTask;</span><br><span class="line">                    futureTask.run(); <span class="comment">// 1.4执行任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.5,</span></span><br><span class="line">                <span class="keyword">return</span> future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                taskCache.remove(taskName, future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行示意图如下：<br><img alt="FutureTask执行示意图.jpg" data-src="https://upload.cc/i1/2020/01/15/Tj6lxz.jpg" class="lazyload"><br>&emsp;&emsp;当两个线程试图同时执行同一个任务时,如果Thread1执行1.3后Thread 2执行2.1,那么接下来Thread 2将在2.2等待,直到Thread1执行完1.4后Thread 2才能从2.2(FutureTask.get())返回  </p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>&emsp;&emsp;FutureTask的实现基于AbstractQueuedSynchronizer(以下简称为AQS).java.util.concurrent中的很多可阻塞类(比如ReentrantLock)都是基于AQS来实现的.AQS是一个同步框架,它提供通用机制来原子性管理同步状态、阻塞和唤醒线程,以及维护被阻塞线程的队列.JDK 6中AQS被广泛使用,基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch和FutureTask  </p>
<p>每一个基于AQS实现的同步器都会包含两种类型的操作,如下:</p>
<ul>
<li>至少一个acquire操作.这个操作阻塞调用线程,除非/直到AQS的状态允许这个线程继续执行.FutureTask的acquire操作为get()/get(long timeout，TimeUnit unit)方法调用</li>
<li>至少一个release操作.这个操作改变AQS的状态,改变后的状态可允许一个或多个阻塞线程被解除阻塞.FutureTask的release操作包括run()方法和cancel(…)方法</li>
</ul>
<p>&emsp;&emsp;基于”复合优先于继承”的原则,FutureTask声明了一个内部私有的继承于AQS的子类Sync,对FutureTask所有公有方法的调用都会委托给这个内部子类<br>&emsp;&emsp;AQS被作为”模板方法模式”的基础类提供给FutureTask的内部子类Sync,这个内部子类只需要实现状态检查和状态更新的方法即可,这些方法将控制FutureTask的获取和释放操作.具体来说,Sync实现了AQS的tryAcquireShared(int)方法和tryReleaseShared(int)方法,Sync通过这两个方法来检查和更新同步状态  </p>
<p>FutureTask的设计示意图如下：<br><img alt="FutureTask的设计示意图.jpg" data-src="https://upload.cc/i1/2020/01/22/gu2VmN.jpg" class="lazyload"><br>&emsp;&emsp;Sync是FutureTask的内部私有类,它继承自AQS.创建FutureTask时会创建内部私有的成员对象Sync,FutureTask所有的的公有方法都直接委托给了内部私有的Sync  </p>
<p>FutureTask.get()方法会调用AQS.acquireSharedInterruptibly(int arg)方法,这个方法的执行过程如下:</p>
<ul>
<li>调用AQS.acquireSharedInterruptibly(int arg)方法,这个方法首先会回调在子类Sync中实现的tryAcquireShared()方法来判断acquire操作是否可以成功.acquire操作可以成功的条件为：state为执行完成状态RAN或已取消状态CANCELLED,且runner不为null</li>
<li>如果成功则get()方法立即返回.如果失败则到线程等待队列中去等待其他线程执行release操作</li>
<li>当其他线程执行release操作(比如FutureTask.run()或FutureTask.cancel(…))唤醒当前线程后,当前线程再次执行tryAcquireShared()将返回正值1,当前线程将离开线程等待队列并唤醒它的后继线程</li>
<li>最后返回计算的结果或抛出异常</li>
</ul>
<p>FutureTask.run()的执行过程如下:</p>
<ul>
<li>执行在构造函数中指定的任务(Callable.call())</li>
<li>以原子方式来更新同步状态(调用AQS.compareAndSetState(int expect，int update),设置state为执行完成状态RAN).如果这个原子操作成功,就设置代表计算结果的变量result的值为Callable.call()的返回值,然后调用AQS.releaseShared(int arg)</li>
<li>AQS.releaseShared(int arg)首先会回调在子类Sync中实现的tryReleaseShared(arg)来执行release操作(设置运行任务的线程runner为null,然会返回true);AQS.releaseShared(int arg),然后唤醒线程等待队列中的第一个线程</li>
<li>调用FutureTask.done()</li>
</ul>
<p>&emsp;&emsp;当执行FutureTask.get()方法时,如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED,当前执行线程将到AQS的线程等待队列中等待(见下图的线程A、B、C和D).当某个线程执行FutureTask.run()方法或FutureTask.cancel(…)方法时,会唤醒线程等待队列的第一<br>个线程(见下图所示的线程E唤醒线程A)<br><img alt="FutureTask的级联唤醒示意图.jpg" data-src="https://upload.cc/i1/2020/01/22/bJX9mx.jpg" class="lazyload">  </p>
<ul>
<li>假设开始时FutureTask处于未启动状态或已启动状态,等待队列中已经有3个线程(A、B和C)在等待.此时,线程D执行get()方法将导致线程D也到等待队列中去等待</li>
<li>当线程E执行run()方法时,会唤醒队列中的第一个线程A.线程A被唤醒后,首先把自己从队列中删除,然后唤醒它的后继线程B,最后线程A从get()方法返回.线程B、C和D重复A线程的处理流程.最终,在队列中等待的所有线程都被级联唤醒并从get()方法返回</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/17-Executor%E6%A1%86%E6%9E%B6/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/17-Executor%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?exec" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/01-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?book" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java并发编程基础</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/01-Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?thread" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>01-Thread源码解析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/02-线程通信/" title="线程通信"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?library"><div class="relatedPosts_title">线程通信</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/03-线程安全/" title="线程安全"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?security"><div class="relatedPosts_title">线程安全</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/07-Java内存模型JMM/" title="JAVA内存模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?beauty"><div class="relatedPosts_title">JAVA内存模型</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/13-Fork Join框架/" title="13-Fork Join框架"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?fork"><div class="relatedPosts_title">13-Fork Join框架</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/08-Java重排序和顺序一致性模型/" title="Java重排序和顺序一致性模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?nature"><div class="relatedPosts_title">Java重排序和顺序一致性模型</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>