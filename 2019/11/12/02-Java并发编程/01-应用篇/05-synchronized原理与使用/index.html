<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>synchronized原理与使用 | Eric Liang</title><meta name="description" content="synchronized原理与使用"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="synchronized原理与使用"><meta name="twitter:description" content="synchronized原理与使用"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?github"><meta property="og:type" content="article"><meta property="og:title" content="synchronized原理与使用"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/05-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="synchronized原理与使用"><meta property="og:image" content="https://source.unsplash.com/300x300/?github"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/05-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"><link rel="prev" title="线程通信" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/02-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"><link rel="next" title="volatile原理和使用" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/04-volatile%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#synchronized原理与使用"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">synchronized原理与使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized是如何实现"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">synchronized是如何实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#理论层面上保证线程安全的原理"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">理论层面上保证线程安全的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM层面上保证线程安全原理"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">JVM层面上保证线程安全原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#反编译"><span class="toc_mobile_items-number">1.1.2.1.</span> <span class="toc_mobile_items-text">反编译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方法"><span class="toc_mobile_items-number">1.1.2.2.</span> <span class="toc_mobile_items-text">同步方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步代码块"><span class="toc_mobile_items-number">1.1.2.3.</span> <span class="toc_mobile_items-text">同步代码块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Java对象头"><span class="toc_mobile_items-number">1.1.2.4.</span> <span class="toc_mobile_items-text">Java对象头</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">1.1.2.5.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized和原子性、可见性、有序性之间的关系"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">synchronized和原子性、可见性、有序性之间的关系</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与原子性"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">synchronized与原子性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与可见性"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">synchronized与可见性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与有序性"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">synchronized与有序性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized与锁优化"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">synchronized与锁优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#偏向锁"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">偏向锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#偏向锁的撤销"><span class="toc_mobile_items-number">1.3.1.1.</span> <span class="toc_mobile_items-text">偏向锁的撤销</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#偏向锁的关闭"><span class="toc_mobile_items-number">1.3.1.2.</span> <span class="toc_mobile_items-text">偏向锁的关闭</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#轻量级锁"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">轻量级锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#轻量级锁加锁"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">轻量级锁加锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#轻量级锁解锁"><span class="toc_mobile_items-number">1.3.2.2.</span> <span class="toc_mobile_items-text">轻量级锁解锁</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁的优缺点对比"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">锁的优缺点对比</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#不使用synchronized如何实现一个线程安全的单例"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">不使用synchronized如何实现一个线程安全的单例</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized原理与使用"><span class="toc-number">1.</span> <span class="toc-text">synchronized原理与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized是如何实现"><span class="toc-number">1.1.</span> <span class="toc-text">synchronized是如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理论层面上保证线程安全的原理"><span class="toc-number">1.1.1.</span> <span class="toc-text">理论层面上保证线程安全的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM层面上保证线程安全原理"><span class="toc-number">1.1.2.</span> <span class="toc-text">JVM层面上保证线程安全原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反编译"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方法"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步代码块"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java对象头"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">Java对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized和原子性、可见性、有序性之间的关系"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized和原子性、可见性、有序性之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与原子性"><span class="toc-number">1.2.1.</span> <span class="toc-text">synchronized与原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与可见性"><span class="toc-number">1.2.2.</span> <span class="toc-text">synchronized与可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与有序性"><span class="toc-number">1.2.3.</span> <span class="toc-text">synchronized与有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized与锁优化"><span class="toc-number">1.3.</span> <span class="toc-text">synchronized与锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁"><span class="toc-number">1.3.1.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#偏向锁的撤销"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">偏向锁的撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#偏向锁的关闭"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">偏向锁的关闭</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级锁"><span class="toc-number">1.3.2.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#轻量级锁加锁"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">轻量级锁加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轻量级锁解锁"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">轻量级锁解锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的优缺点对比"><span class="toc-number">1.3.3.</span> <span class="toc-text">锁的优缺点对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不使用synchronized如何实现一个线程安全的单例"><span class="toc-number">1.4.</span> <span class="toc-text">不使用synchronized如何实现一个线程安全的单例</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">synchronized原理与使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-04</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/">01-应用篇</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="synchronized原理与使用"><a href="#synchronized原理与使用" class="headerlink" title="synchronized原理与使用"></a>synchronized原理与使用</h1><p>&emsp;&emsp;synchronized是Java中用于解决并发情况下数据同步访问的一个很重要的关键字.当我们想要保证一个共享资源在同一时间只会被一个线程访问到时,我们可以在代码中使用synchronized关键字对类或者对象加锁.那么本文来介绍一下synchronized关键字的实现原理是什么.在阅读本文之间,建议先看下<a href="http://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a>  </p>
<h2 id="synchronized是如何实现"><a href="#synchronized是如何实现" class="headerlink" title="synchronized是如何实现"></a>synchronized是如何实现</h2><h3 id="理论层面上保证线程安全的原理"><a href="#理论层面上保证线程安全的原理" class="headerlink" title="理论层面上保证线程安全的原理"></a>理论层面上保证线程安全的原理</h3><p>Java每一个对象都可以作为锁.具体表现：</p>
<ul>
<li>对于普通方法,锁是当前实例对象,this对象</li>
<li>对于静态同步方法,锁是当前类的Class对象</li>
<li>对于同步方法块,锁是Synchronized括号里配置的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized放在普通方法上,内置锁就是当前类的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修饰静态方法:内置锁是当前Class字节码对象Sequence.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Sequence<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM层面上保证线程安全原理"><a href="#JVM层面上保证线程安全原理" class="headerlink" title="JVM层面上保证线程安全原理"></a>JVM层面上保证线程安全原理</h3><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4>&emsp;&emsp;众所周知在Java中,synchronized有两种使用形式(同步方法和同步代码块).代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们先来使用Javap来反编译以上代码,结果如下(部分无用信息过滤掉了)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello World</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #5                  // class com/hollis/SynchronizedTest</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #3                  // String Hello World</span><br><span class="line">        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
&emsp;&emsp;反编译后,我们可以看到Java编译器为我们生成的字节码.在对于doSth和doSth1的处理上稍有不同.也就是说JVM对于同步方法和同步代码块的处理方式不同<br>&emsp;&emsp;对于同步方法,JVM采用ACC_SYNCHRONIZED标记符来实现同步;对于同步代码块,JVM采用monitorenter、monitorexit两个指令来实现同步  </li>
</ul>
<p>关于这部分内容,在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：<br>&emsp;&emsp;主要说的是：方法级的同步是隐式的.同步方法的常量池中会有一个ACC_SYNCHRONIZED标志.当某个线程要访问某个方法的时候,会检查是否有ACC_SYNCHRONIZED,如果有设置,则需要先获得监视器锁,然后开始执行方法,方法执行之后再释放监视器锁.这时如果其他线程来请求执行方法,会因为无法获得监视器锁而被阻断住.值得注意的是,如果在方法执行过程中,发生了异常,并且方法内部并没有处理该异常,那么在异常被抛到方法外面之前监视器锁会被自动释放</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>&emsp;&emsp;monitorenter指令是在编译后插入到同步代码块的开始位置,而monitorexit是插入到方法结束处和异常处,JVM要保证每个monitorenter必须有对应的monitorexit与之配对.任何对象都有一个monitor与之关联,当且一个monitor被持有后,它将处于锁定状态.线程执行到monitorenter指令时,将会尝试获取对象所对应的monitor的所有权,即尝试获得对象的锁  </p>
<p>同步代码块使用monitorenter和monitorexit两个指令实现.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于这两个指令的介绍：<br>&emsp;&emsp;大致内容如下：可以把执行monitorenter指令理解为加锁,执行monitorexit理解为释放锁.每个对象维护着一个记录着被锁次数的计数器.未被锁定的对象的该计数器为0,当一个线程获得锁(执行monitorenter)后,该计数器自增变为1,当同一个线程再次获得该对象的锁的时候,计数器再次自增.当同一个线程释放锁(执行monitorexit指令)的时候,计数器再自减.当计数器为0的时候,锁将被释放,其他线程便可以获得锁<br><img alt="对象、监视器、同步队列和执行线程之间的关系" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-Synchronized/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%9B%91%E8%A7%86%E5%99%A8%E3%80%81%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%92%8C%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg?raw=true" class="lazyload">  </p>
<h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>&emsp;&emsp;synchronized用的锁是存在Java对象头里的.如果对象是数组类型,则虚拟机用3个字宽(Word)存储对象头,如果对象是非数组类型,则用2字宽存储对象头.在32位虚拟机中,1字宽等于4字节,即32bit,如下表所示</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64bit</td>
<td align="center">Mark Word</td>
<td align="center">存储对象的hashcode或锁信息等</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Class Metadata Address</td>
<td align="center">存储到对象类型数据的指针</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Array length</td>
<td align="center">数组的长度(如果当前对象是数组)</td>
</tr>
</tbody></table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位.32位JVM<br>的Mark Word的默认存储结构如下表所示</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25bit</th>
<th align="center">4bit</th>
<th align="center">1bit是否是偏向锁</th>
<th align="center">2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象的hashcode</td>
<td align="center">对象分代年龄</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
</tbody></table>
<p>在运行期间,Mark Word里存储的数据会随着锁标志位的变化而变化.Mark Word可能变化为存储以下4种数据,如下表所示<br><img alt="Mark Word的状态变化" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-Synchronized/Mark%20Word%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpg?raw=true" class="lazyload"><br>在64位虚拟机下,Mark Word是64bit大小的,其存储结构如下表所示：<br><img alt="64位Mark Word的存储结构" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-Synchronized/64%E4%BD%8DMark%20Word%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" class="lazyload">  </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁.当线程要执行的方法被标注上ACC_SYNCHRONIZED时,需要先获得锁才能执行该方法<br>&emsp;&emsp;同步代码块通过monitorenter和monitorexit执行来进行加锁.当线程执行到monitorenter的时候要先获得所锁,才能执行后面的方法.当线程执行到monitorexit的时候则要释放锁<br>&emsp;&emsp;每个对象自身维护这一个被加锁次数的计数器,当计数器数字为0时表示可以被任意线程获得锁.当计数器不为0时,只有获得锁的线程才能再次获得锁.即可重入锁<br>&emsp;&emsp;无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的,在Java虚拟机(HotSpot)中,Monitor是基于C++实现的,由ObjectMonitor实现<br>&emsp;&emsp;ObjectMonitor类中提供了几个方法,如enter、exit、wait、notify、notifyAll等.sychronized加锁的时候,会调用objectMonitor的enter方法,解锁的时候会调用exit方法(关于Monitor详见<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程(四)—— Moniter的实现原理</a>)</p>
<h2 id="synchronized和原子性、可见性、有序性之间的关系"><a href="#synchronized和原子性、可见性、有序性之间的关系" class="headerlink" title="synchronized和原子性、可见性、有序性之间的关系"></a>synchronized和原子性、可见性、有序性之间的关系</h2><h3 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h3><p>&emsp;&emsp;原子性是指一个操作是不可中断的,要全部执行完成,要不就都不执行<br>&emsp;&emsp;线程是CPU调度的基本单位.CPU有时间片的概念,会根据不同的调度算法进行线程调度.当一个线程获得时间片之后开始执行,在时间片耗尽之后,就会失去CPU使用权.所以在多线程场景下,由于时间片在线程间轮换,就会发生原子性问题<br>&emsp;&emsp;在Java中,为了保证原子性,提供了两个高级的字节码指令monitorenter和monitorexit.前面中介绍过,这两个字节码指令,在Java中对应的关键字就是synchronized<br>&emsp;&emsp;通过monitorenter和monitorexit指令,可以保证被synchronized修饰的代码在同一时间只能被一个线程访问,在锁未释放之前,无法被其他线程访问到.因此在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的  </p>
<blockquote>
<p>线程1在执行monitorenter指令的时候,会对Monitor进行加锁,加锁后其他线程无法获得锁,除非线程1主动解锁.即使在执行过程中,由于某种原因,比如CPU时间片用完,线程1放弃了CPU,但是他并没有进行解锁.而由于synchronized的锁是可重入的,下一个时间片还是只能被他自己获取到,还是会继续执行代码.直到所有代码执行完.这就保证了原子性</p>
</blockquote>
<h3 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h3><p>可见性是指当多个线程访问同一个变量时,一个线程修改了这个变量的值,其他线程能够立即看得到修改的值</p>
<p>&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存,线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝,线程对变量的所有操作都必须在工作内存中进行,而不能直接读写主内存.不同的线程之间也无法直接访问对方工作内存中的变量,线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行.所以就可能出现线程1改了某个变量的值,但是线程2不可见的情况<br>&emsp;&emsp;前面我们介绍过,被synchronized修饰的代码,在开始执行时会加锁,执行完成后会进行解锁.而为了保证可见性,有一条规则是这样的：对一个变量解锁之前,必须先把此变量同步回主存中.这样解锁后,后续线程就可以访问到被修改后的值<br>所以synchronized关键字锁住的对象,其值是具有可见性的</p>
<h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行</p>
<p>&emsp;&emsp;在Java内存模型中分析过：除了引入了时间片以外,由于处理器优化和指令重排等,CPU还可能对输入代码进行乱序执行,比如load-&gt;add-&gt;save有可能被优化成load-&gt;save-&gt;add.这就是可能存在有序性问题<br>&emsp;&emsp;这里需要注意的是：synchronized是无法禁止指令重排和处理器优化的.也就是说,synchronized无法避免上述提到的问题  </p>
<p>为什么还说synchronized也提供了有序性保证呢?<br>&emsp;&emsp;这就要再把有序性的概念扩展一下了.Java程序中天然的有序性可以总结为一句话：如果在本线程内观察,所有操作都是天然有序的.如果在一个线程中观察另一个线程,所有操作都是无序的<br>&emsp;&emsp;这其实和as-if-serial语义有关;as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度),单线程程序的执行结果都不能被改变.编译器和处理器无论如何优化,都必须遵守as-if-serial语义<br>&emsp;&emsp;简单说就是：as-if-serial语义保证了单线程中,指令重排是有一定的限制的,而只要编译器和处理器都遵守了这个语义,那么就可以认为单线程程序是按照顺序执行的.当然实际上还是有重排的,只不过我们无须关心这种重排的干扰<br>&emsp;&emsp;所以呢由于synchronized修饰的代码,同一时间只能被同一线程访问.那么也就是单线程执行的.所以可以保证其有序性</p>
<h2 id="synchronized与锁优化"><a href="#synchronized与锁优化" class="headerlink" title="synchronized与锁优化"></a>synchronized与锁优化</h2><p>&emsp;&emsp;synchronized其实是借助Monitor实现的,在加锁时会调用objectMonitor的enter方法,解锁的时候会调用exit方法.事实上只有在JDK1.6之前,synchronized的实现才会直接调用ObjectMonitor的enter和exit,这种锁被称之为重量级锁<br>&emsp;&emsp;在JDK1.6中出现对锁进行了很多的优化,进而出现轻量级锁、偏向锁、锁消除、适应性自旋锁、锁粗化(自旋锁在1.4就有,只不过默认的是关闭的,jdk1.6是默认开启的),这些操作都是为了在线程之间更高效的共享数据,解决竞争问题<br>&emsp;&emsp;锁一共有4种状态,级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态,这几个状态会随着竞争情况逐渐升级.锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁.这种锁升级却不能降级的策略,目的是为了提高获得锁和释放锁的效率,下文会详细分析</p>
<p>关于自旋锁、锁粗化和锁消除可以参考<a href="http://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">深入理解多线程(五)—— Java虚拟机的锁优化技术</a></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>&emsp;&emsp;很多情况下,竞争锁不是由多个线程,而是由一个线程在使用.相当于单线程在访问,每次像多线程获取资源会浪费资源,于是就有了偏向锁 </p>
<p>&emsp;&emsp;当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID.</p>
<ul>
<li>该线程再次在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁.如果测试成功,表示线程已经获得了锁.</li>
<li>如果测试失败,则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁);如果没有设置,则使用CAS竞争锁;如果设置了.则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ul>
<p>偏向锁的使用场景是只有一个线程访问同步代码块的场景</p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>&emsp;&emsp;偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他锁尝试竞争偏向锁的时候持有偏向锁的线程才会去释放偏向锁<br>&emsp;&emsp;偏向锁的撤销,需要等待全局安全点(在这个时间点上没有正在执行的字节码).它会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否活着,如果线程不处于活动状态,则将对象头设置成无锁状态;如果线程仍然活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程,要么恢复到无锁或者标记对象不适合作为偏向锁,最后唤醒暂停的线程<br><img alt="偏向锁的初始化与撤销" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-Synchronized/%E5%81%8F%E5%90%91%E9%94%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%92%A4%E9%94%80.jpg?raw=true" class="lazyload"></p>
<h4 id="偏向锁的关闭"><a href="#偏向锁的关闭" class="headerlink" title="偏向锁的关闭"></a>偏向锁的关闭</h4><p>&emsp;&emsp;偏向锁在Java 6和Java 7里是默认启用的,但是它在应用程序启动几秒钟之后才激活,如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0.如果你确定应用程序里所有的锁通常情况下处于竞争状态,可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false,那么程序默认会进入轻量级锁状态</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>可以同时让多个线程进入同步代码块中,同时都能获取锁  </p>
<h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>&emsp;&emsp;轻量级锁是如何加锁的?在线程执行同步代码块前,java虚拟机会先在当前线程的栈帧中创建用于锁记录的空间,并将对象头中的MarkWord复制到锁记录空间,官方称为Displaced Mark Word.然后线程尝试使用<br>CAS将对象头中的Mark Word替换为指向锁记录的指针,当竞争成功后,MarkWord就会把锁标志位改成轻量级锁,当前线程获得锁,接着执行同步体;当竞争失<br>败,表示其他线程竞争锁,当前线程便尝试使用自旋来获取锁<br>&emsp;&emsp;比如多个线程一块访问,一个获取了轻量级锁,另外一个需要等待执行,它也要复制MarkWord到虚拟机栈中,接着她要修改MarkWord,发现被别的线程获得了锁,它修改不成功,就不停的去修改,不停的失败,直到前面的线程将锁给释放了,于是它可以获得了,上述的过程就是<font color="red">自旋</font>锁<br>&emsp;&emsp;当第一个线程执行完毕后,第二个线程获取到之后就把锁升级成重量级锁,线程就会阻塞,当第一个线程执行完毕释放锁并唤醒第二个线程,接着第二个线程开始继续执行,这就是轻量级锁的执行过程</p>
<h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>&emsp;&emsp;轻量级解锁时,会使用原子的CAS操作将Displaced Mark Word替换回到对象头,如果成功,则表示没有竞争发生.如果失败,表示当前锁存在竞争,锁就会膨胀成重量级锁.下图是两个线程同时争夺锁,导致锁膨胀的流程图<br><img alt="锁膨胀的流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-Synchronized/%E9%94%81%E8%86%A8%E8%83%80.jpg?raw=true" class="lazyload"><br>&emsp;&emsp;因为自旋会消耗CPU,为了避免无用的自旋(比如获得锁的线程被阻塞住了),一旦锁升级成重量级锁,就不会再恢复到轻量级锁状态.当锁处于这个状态下,其他线程试图获取锁时,都会被阻塞住,当持有锁的线程释放锁之后会唤醒这些线程,被唤醒的线程就会进行新一轮的夺锁之争</p>
<h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差异</td>
<td align="center">如果线程间存在锁竞争会带来额外的锁撤销的消耗</td>
<td align="center">适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">竞争的线程不会存在阻塞,提高了线程的响应速度</td>
<td align="center">如果始终得不到锁竞争的线程,使用自旋会消耗CPU</td>
<td align="center">追求响应时间,同步块执行速度非常快</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">线程竞争不使用自旋,不会消耗CPU</td>
<td align="center">线程阻塞,响应时间缓慢</td>
<td align="center">追求吞吐量,同步块执行速度</td>
</tr>
<tr>
<td align="center">## synchronized和lock之间的关系</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="不使用synchronized如何实现一个线程安全的单例"><a href="#不使用synchronized如何实现一个线程安全的单例" class="headerlink" title="不使用synchronized如何实现一个线程安全的单例"></a>不使用synchronized如何实现一个线程安全的单例</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/05-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/05-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?github" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/02-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?library" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>线程通信</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/04-volatile%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?document" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>volatile原理和使用</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/02-线程通信/" title="线程通信"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?library"><div class="relatedPosts_title">线程通信</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/03-线程安全/" title="线程安全"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?security"><div class="relatedPosts_title">线程安全</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/07-Java内存模型JMM/" title="JAVA内存模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?beauty"><div class="relatedPosts_title">JAVA内存模型</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/13-Fork Join框架/" title="13-Fork Join框架"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?fork"><div class="relatedPosts_title">13-Fork Join框架</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/08-Java重排序和顺序一致性模型/" title="Java重排序和顺序一致性模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?nature"><div class="relatedPosts_title">Java重排序和顺序一致性模型</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>