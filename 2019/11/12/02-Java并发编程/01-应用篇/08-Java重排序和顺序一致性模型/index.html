<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java重排序和顺序一致性模型 | Eric Liang</title><meta name="description" content="Java重排序和顺序一致性模型"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java重排序和顺序一致性模型"><meta name="twitter:description" content="Java重排序和顺序一致性模型"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?nature"><meta property="og:type" content="article"><meta property="og:title" content="Java重排序和顺序一致性模型"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="Java重排序和顺序一致性模型"><meta property="og:image" content="https://source.unsplash.com/300x300/?nature"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/"><link rel="prev" title="JAVA内存模型" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/07-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/"><link rel="next" title="14-Java中的13个原子操作类" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/14-Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java重排序和顺序一致性模型"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java重排序和顺序一致性模型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重排序"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">重排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据依赖性"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">数据依赖性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#as-if-serial语义"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">as-if-serial语义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序顺序规则"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">程序顺序规则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#重排序对多线程的影响"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">重排序对多线程的影响</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#顺序一致性"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">顺序一致性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据竞争与顺序一致性"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">数据竞争与顺序一致性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#顺序一致性内存模型"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">顺序一致性内存模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#同步程序的顺序一致性效果"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">同步程序的顺序一致性效果</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#未同步程序的执行特性"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">未同步程序的执行特性</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java重排序和顺序一致性模型"><span class="toc-number">1.</span> <span class="toc-text">Java重排序和顺序一致性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重排序"><span class="toc-number">1.1.</span> <span class="toc-text">重排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据依赖性"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据依赖性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-if-serial语义"><span class="toc-number">1.1.2.</span> <span class="toc-text">as-if-serial语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序顺序规则"><span class="toc-number">1.1.3.</span> <span class="toc-text">程序顺序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排序对多线程的影响"><span class="toc-number">1.1.4.</span> <span class="toc-text">重排序对多线程的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序一致性"><span class="toc-number">1.2.</span> <span class="toc-text">顺序一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据竞争与顺序一致性"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据竞争与顺序一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序一致性内存模型"><span class="toc-number">1.2.2.</span> <span class="toc-text">顺序一致性内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步程序的顺序一致性效果"><span class="toc-number">1.2.3.</span> <span class="toc-text">同步程序的顺序一致性效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未同步程序的执行特性"><span class="toc-number">1.2.4.</span> <span class="toc-text">未同步程序的执行特性</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">Java重排序和顺序一致性模型</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-04</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/">01-应用篇</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Java重排序和顺序一致性模型"><a href="#Java重排序和顺序一致性模型" class="headerlink" title="Java重排序和顺序一致性模型"></a>Java重排序和顺序一致性模型</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>&emsp;&emsp;如果两个操作访问同一个变量,且这两个操作中有一个为写操作,此时这两个操作之间就存在数据依赖性.数据依赖分为下列3种类型,如下表所示  </p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">代码示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">写后读</td>
<td align="center">a=1; b=a</td>
<td align="center">写一个变量后,再读这个位置</td>
</tr>
<tr>
<td align="center">写后写</td>
<td align="center">a=1; a=2</td>
<td align="center">写一个变量后,再写这个变量</td>
</tr>
<tr>
<td align="center">读后写</td>
<td align="center">a=b; b=2</td>
<td align="center">读一个变量后,再写这个变量</td>
</tr>
</tbody></table>
<p>上面3种情况,只要重排序两个操作的执行顺序,程序的执行结果就会被改变</p>
<p>&emsp;&emsp;前面提到过,编译器和处理器可能会对操作做重排序.编译器和处理器在重排序时,会遵守数据依赖性,编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序<br>&emsp;&emsp;这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作,不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>&emsp;&emsp;as-if-serial语义的意思是：不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变.编译器、runtime和处理器都必须遵守as-if-serial语义<br>&emsp;&emsp;为了遵守as-if-serial语义,编译器和处理器不会对存在数据依赖关系的操作做重排序,因为这种重排序会改变执行结果.但是,如果操作之间不存在数据依赖关系,这些操作就可能被编译器和处理器重排序.为了具体说明,请看下面计算圆面积的代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>; <span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<p>上面3个操作的数据依赖关系如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;C</span><br><span class="line">B--&gt;C</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上图所示,A和C之间存在数据依赖关系,同时B和C之间也存在数据依赖关系.因此在最终执行的指令序列中,C不能被重排序到A和B的前面(C排到A和B的前面,程序的结果将会被改变).但A和B之间没有数据依赖关系,编译器和处理器可以重排序A和B之间的执行顺序<br>该程序的两种执行顺序:</p>
<ol>
<li>按程序顺序执行结果: area=3.14<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br><span class="line">B--&gt;C</span><br></pre></td></tr></table></figure></li>
<li>重排序执行结果: area=3.14<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">B--&gt;A</span><br><span class="line">A--&gt;C</span><br></pre></td></tr></table></figure>
&emsp;&emsp;as-if-serial语义把单线程程序保护了起来,遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的.asif-serial语义使单线程程序员无需担心重排序会干扰他们,也无需担心内存可见性问题<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3>根据happens-before的程序顺序规则,上面计算圆的面积的示例代码存在3个happensbefore关系:</li>
<li>A happens-before B</li>
<li>B happens-before C</li>
<li>A happens-before C</li>
</ol>
<p>这里的第3个happens-before关系,是根据happens-before的传递性推导出来的<br>&emsp;&emsp;这里A happens-before B,但实际执行时B却可以排在A之前执行(看上面的重排序后的执行顺序).如果A happens-before B,JMM并不要求A一定要在B之前执行.JMM仅仅要求前一个操作(执行的结果)对后一个操作可见,且前一个操作按顺序排在第二个操作之前.这里操作A的执行结果不需要对操作B可见;而且重排序操作A和操作B后的执行结果,与操作A和操作B按happens-before顺序执行的结果一致.在这种情况下,JMM会认为这种重排序并不非法(not illegal),JMM允许这种重排序</p>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>现在让我们来看看,重排序是否会改变多线程程序的执行结果.请看下面的示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag变量是个标记,用来标识变量a是否已被写入.这里假设有两个线程A和B,A首先执行writer()方法,随后B线程接着执行reader()方法.线程B在执行操作4时,能否看到线程A在操作1对共享变量a的写入呢?  </p>
<p>答案是：<font color="red">不一定能看到</font></p>
<p>&emsp;&emsp;由于操作1和操作2没有数据依赖关系,编译器和处理器可以对这两个操作重排序;同样,操作3和操作4没有数据依赖关系,编译器和处理器也可以对这两个操作重排序.让我们先来看看,当操作1和操作2重排序时,可能会产生什么效果?请看下面的程序执行时序图,如下图所示<br><img alt="操作1和操作2重排序" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%93%8D%E4%BD%9C1%E5%92%8C%E6%93%8D%E4%BD%9C2%E9%87%8D%E6%8E%92%E5%BA%8F.jpg?raw=true" class="lazyload"><br>操作1和操作2做了重排序.程序执行时,线程A首先写标记变量flag,随后线程B读这个变量.由于条件判断为真,线程B将读取变量a.此时,变量a还没有被线程A写入,在这里多线程程序的语义被重排序破坏了<br>&emsp;&emsp;下面再让我们看看,当操作3和操作4重排序时会产生什么效果(借助这个重排序,可以顺便说明控制依赖性).下面是操作3和操作4重排序后,程序执行的时序图<br><img alt="操作3和操作4重排序" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%93%8D%E4%BD%9C3%E5%92%8C%E6%93%8D%E4%BD%9C4%E9%87%8D%E6%8E%92%E5%BA%8F.jpg?raw=true" class="lazyload"><br>&emsp;&emsp;在程序中,操作3和操作4存在控制依赖关系.当代码中存在控制依赖性时,会影响指令序列执行的并行度.为此,编译器和处理器会采用猜测(Speculation)执行来克服控制相关性对并行度的影响.以处理器的猜测执行为例,执行线程B的处理器可以提前读取并计算a*a,然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中.当操作3的条件判断为真时,就把该计算结果写入变量i中<br>&emsp;&emsp;从上图可以看出,猜测执行实质上对操作3和4做了重排序.重排序在这里破坏了多线程程序的语义  </p>
<p>&emsp;&emsp;在单线程程序中,对存在控制依赖的操作重排序,不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因);但在多线程程序中,对存在控制依赖的操作重排序,可能会改变程序的执行结果</p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>顺序一致性内存模型是一个理论参考模型,在设计的时候,处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照</p>
<h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步时,就可能会存在数据竞争.Java内存模型规范对数据竞争的定义如下:</p>
<ol>
<li>在一个线程中写一个变量</li>
<li>在另一个线程读同一个变量</li>
<li>而且写和读没有通过同步来排序</li>
</ol>
<p>当代码中包含数据竞争时,程序的执行往往产生违反直觉的结果(前面的示例正是如<br>此).如果一个多线程程序能正确同步,这个程序将是一个没有数据竞争的程序</p>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：<br>&emsp;&emsp;如果程序是正确同步的,程序的执行将具有顺序一致性(Sequentially Consistent)——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同.马上我们就会看到,这对于程序员来说是一个极强的保证.这里的同步是指广义上的同步,包括对常用同步原语(synchronized、volatile和final)的正确使用</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型,它为程序员提供了极强的内存可见性保证.顺序一致性内存模型有两大特性：</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>(不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序.在顺序一致性内存模型中,每个操作都必须原子执行且立刻对所有线程可见</li>
</ol>
<p>顺序一致性内存模型为程序员提供的视图如下：<br><img alt="顺序一致性内存模型" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg?raw=true" class="lazyload"><br>&emsp;&emsp;在概念上,顺序一致性模型有一个单一的全局内存,这个内存通过一个左右摆动的开关可以连接到任意一个线程,同时每一个线程必须按照程序的顺序来执行内存读/写操作.从上面的示意图可以看出,在任意时间点最多只能有一个线程可以连接到内存.当多个线程并发执行时,图中的开关装置能把所有线程的所有内存读/写操作串行化(即在顺序一致性模型中,所有操作之间具有全序关系)</p>
<p>为了更好进行理解,下面通过两个示意图来对顺序一致性模型的特性做进一步的说明：<br>&emsp;&emsp;假设有两个线程A和B并发执行.其中A线程有3个操作,它们在程序中的顺序是：A1→A2→A3.B线程也有3个操作,它们在程序中的顺序是：B1→B2→B3<br>&emsp;&emsp;假设这两个线程使用监视器锁来正确同步：A线程的3个操作执行后释放监视器锁,随后B线程获取同一个监视器锁.那么程序在顺序一致性模型中的执行效果将如下图所示：<br><img alt="顺序一致性模型的一种执行效果" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.jpg?raw=true" class="lazyload"><br>现在我们再假设这两个线程没有做同步,下面是这个未同步程序在顺序一致性模型中的执行示意图：<br><img alt="顺序一致性模型中的另一种执行效果" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.jpg?raw=true" class="lazyload"><br>&emsp;&emsp;未同步程序在顺序一致性模型中虽然整体执行顺序是无序的,但所有线程都只能看到一个一致的整体执行顺序.以上图为例,线程A和B看到的执行顺序都是：B1→A1→A2→B2→A3→B3.之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见<br>&emsp;&emsp;但是,在JMM中就没有这个保证.未同步程序在JMM中不但整体的执行顺序是无序的,而且所有线程看到的操作执行顺序也可能不一致.比如,在当前线程把写过的数据缓存在本地内存中,在没有刷新到主内存之前,这个写操作仅对当前线程可见;从其他线程的角度来观察,会认为这个写操作根本没有被当前线程执行.只有当前线程把本地内存中写过的数据刷新到主内存之后,这个写操作才能对其他线程可见.在这种情况下,当前线程和其他线程看到的操作执行顺序将不一致</p>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><p>下面对前面的示例程序ReorderExample用锁来同步,看看正确同步的程序如何具有顺序一致性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取锁</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面示例代码中,假设A线程执行writer()方法后,B线程执行reader()方法.这是一个正确同步的多线程程序.根据JMM规范,该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同.下面是该程序在两个内存模型中的执行时序对比图,如下图所示<br>&emsp;&emsp;顺序一致性模型中,所有操作完全按程序的顺序串行执行.而在JMM中,临界区内的代码可以重排序(但JMM不允许临界区内的代码”逸出”到临界区之外,那样会破坏监视器的语义).JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理,使得线程在这两个时间点具有与顺序一致性模型相同的内存视图(具体细节后文会说明).虽然线程A在临界区内做了重排序,但由于监视器互斥执行的特性,这里的线程B根本无法”观察”到线程A在临界区内的重排序.这种重排序既提高了执行效率,又没有改变程序的执行结果<br><img alt="两个内存模型中的执行时序对比" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E4%B8%A4%E4%B8%AA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%AF%B9%E6%AF%94.jpg?raw=true" class="lazyload"><br>从这里我们可以看到,JMM在具体实现上的基本方针为：在不改变(正确同步的)程序执行结果的前提下,尽可能地为编译器和处理器的优化打开方便之门</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>&emsp;&emsp;对于未同步或未正确同步的多线程程序,JMM只提供最小安全性：线程执行时读取到的值,要么是之前某个线程写入的值,要么是默认值(0，Null，False),JMM保证线程读操作读取到的值不会无中生有(Out Of Thin Air)的冒出来.为了实现最小安全性,JVM在堆上分配对象时,首先会对内存空间进行清零,然后才会在上面分配对象(JVM内部会同步这两个操作).因此,在已清零的内存空间(Pre-zeroed Memory)分配对象时,域的默认初始化已经完成了<br>&emsp;&emsp;JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致.因为如果想要保证执行结果一致,JMM需要禁止大量的处理器和编译器的优化,这对程序的执行性能会产生很大的影响.而且未同步程序在顺序一致性模型中执行时,整体是无序的,其执行结果往往无法预知.而且,保证未同步程序在这两个模型中的执行结果一致没什么意义  </p>
<p>未同步程序在JMM中的执行时,整体上是无序的,其执行结果无法预知.未同步程序在两个模型中的执行特性有如下几个差异:</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行,而JMM不保证单线程内的操作会按程序的顺序执行(比如上面正确同步的多线程程序在临界区内的重排序)</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序,而JMM不保证所有线程能看到一致的操作执行顺序</li>
<li>JMM不保证对64位的long型和double型变量的写操作具有原子性,而顺序一致性模型保证对所有的内存读/写操作都具有原子性</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-Java%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?nature" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/07-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?beauty" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>JAVA内存模型</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/14-Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?atom" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>14-Java中的13个原子操作类</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/13-Fork Join框架/" title="13-Fork Join框架"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?fork"><div class="relatedPosts_title">13-Fork Join框架</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/07-Java内存模型JMM/" title="JAVA内存模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?beauty"><div class="relatedPosts_title">JAVA内存模型</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/14-Java中的13个原子操作类/" title="14-Java中的13个原子操作类"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?atom"><div class="relatedPosts_title">14-Java中的13个原子操作类</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/12-阻塞队列/" title="12-阻塞队列"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?block"><div class="relatedPosts_title">12-阻塞队列</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/09-happens-before规则、双重检查锁定与延迟初始化/" title="09-happens-before规则、双重检查锁定与延迟初始化"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?happens"><div class="relatedPosts_title">09-happens-before规则、双重检查锁定与延迟初始化</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>