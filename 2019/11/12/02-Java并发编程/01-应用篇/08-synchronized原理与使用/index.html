<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>synchronized原理与使用 | Eric Liang</title><meta name="description" content="synchronized原理与使用"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="synchronized原理与使用"><meta name="twitter:description" content="synchronized原理与使用"><meta name="twitter:image" content="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><meta property="og:type" content="article"><meta property="og:title" content="synchronized原理与使用"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="synchronized原理与使用"><meta property="og:image" content="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"><link rel="prev" title="volatile原理和使用" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/09-volatile%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"><link rel="next" title="fail-fast机制" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/Fail-Fast%E6%9C%BA%E5%88%B6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#synchronized原理与使用"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">synchronized原理与使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized是如何实现"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">synchronized是如何实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#理论层面上保证线程安全的原理"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">理论层面上保证线程安全的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM层面上保证线程安全原理"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">JVM层面上保证线程安全原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#反编译"><span class="toc_mobile_items-number">1.1.2.1.</span> <span class="toc_mobile_items-text">反编译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方法"><span class="toc_mobile_items-number">1.1.2.2.</span> <span class="toc_mobile_items-text">同步方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步代码块"><span class="toc_mobile_items-number">1.1.2.3.</span> <span class="toc_mobile_items-text">同步代码块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">1.1.2.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized和原子性、可见性、有序性之间的关系"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">synchronized和原子性、可见性、有序性之间的关系</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与原子性"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">synchronized与原子性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与可见性"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">synchronized与可见性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized与有序性"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">synchronized与有序性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized与锁优化"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">synchronized与锁优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#偏向锁"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">偏向锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#轻量级锁"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">轻量级锁</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized和lock之间的关系"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">synchronized和lock之间的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#不使用synchronized如何实现一个线程安全的单例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">不使用synchronized如何实现一个线程安全的单例</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized原理与使用"><span class="toc-number">1.</span> <span class="toc-text">synchronized原理与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized是如何实现"><span class="toc-number">1.1.</span> <span class="toc-text">synchronized是如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理论层面上保证线程安全的原理"><span class="toc-number">1.1.1.</span> <span class="toc-text">理论层面上保证线程安全的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM层面上保证线程安全原理"><span class="toc-number">1.1.2.</span> <span class="toc-text">JVM层面上保证线程安全原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反编译"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方法"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步代码块"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized和原子性、可见性、有序性之间的关系"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized和原子性、可见性、有序性之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与原子性"><span class="toc-number">1.2.1.</span> <span class="toc-text">synchronized与原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与可见性"><span class="toc-number">1.2.2.</span> <span class="toc-text">synchronized与可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与有序性"><span class="toc-number">1.2.3.</span> <span class="toc-text">synchronized与有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized与锁优化"><span class="toc-number">1.3.</span> <span class="toc-text">synchronized与锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁"><span class="toc-number">1.3.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级锁"><span class="toc-number">1.3.2.</span> <span class="toc-text">轻量级锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized和lock之间的关系"><span class="toc-number">1.4.</span> <span class="toc-text">synchronized和lock之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不使用synchronized如何实现一个线程安全的单例"><span class="toc-number">1.5.</span> <span class="toc-text">不使用synchronized如何实现一个线程安全的单例</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url((设置顶部图))"><div id="post-info"><div id="post-title"><div class="posttitle">synchronized原理与使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-02</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/">01-应用篇</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="synchronized原理与使用"><a href="#synchronized原理与使用" class="headerlink" title="synchronized原理与使用"></a>synchronized原理与使用</h1><p>synchronized是Java中用于解决并发情况下数据同步访问的一个很重要的关键字.当我们想要保证一个共享资源在同一时间只会被一个线程访问到时,我们可以在代码中使用synchronized关键字对类或者对象加锁.那么本文来介绍一下synchronized关键字的实现原理是什么.在阅读本文之间,建议先看下<a href="http://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a> </p>
<h2 id="synchronized是如何实现"><a href="#synchronized是如何实现" class="headerlink" title="synchronized是如何实现"></a>synchronized是如何实现</h2><h3 id="理论层面上保证线程安全的原理"><a href="#理论层面上保证线程安全的原理" class="headerlink" title="理论层面上保证线程安全的原理"></a>理论层面上保证线程安全的原理</h3><ul>
<li>内置锁：Java中每个对象都可以作为内置(同步)锁</li>
<li>锁的互斥(互斥锁):<ul>
<li>修饰普通方法：内置锁就是当前类的实例,this对象</li>
<li>修饰镜头方法：内置锁就是当前Class字节码对象</li>
<li>修饰代码块：指定的锁对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized放在普通方法上,内置锁就是当前类的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修饰静态方法:内置锁是当前Class字节码对象Sequence.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Sequence<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM层面上保证线程安全原理"><a href="#JVM层面上保证线程安全原理" class="headerlink" title="JVM层面上保证线程安全原理"></a>JVM层面上保证线程安全原理</h3><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4>&emsp;&emsp;众所周知在Java中,synchronized有两种使用形式(同步方法和同步代码块).代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们先来使用Javap来反编译以上代码,结果如下(部分无用信息过滤掉了)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello World</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #5                  // class com/hollis/SynchronizedTest</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #3                  // String Hello World</span><br><span class="line">        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
&emsp;&emsp;反编译后,我们可以看到Java编译器为我们生成的字节码.在对于doSth和doSth1的处理上稍有不同.也就是说JVM对于同步方法和同步代码块的处理方式不同<br>&emsp;&emsp;对于同步方法,JVM采用ACC_SYNCHRONIZED标记符来实现同步;对于同步代码块,JVM采用monitorenter、monitorexit两个指令来实现同步  </li>
</ul>
</li>
</ul>
<p>关于这部分内容,在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：<br>&emsp;&emsp;主要说的是：方法级的同步是隐式的.同步方法的常量池中会有一个ACC_SYNCHRONIZED标志.当某个线程要访问某个方法的时候,会检查是否有ACC_SYNCHRONIZED,如果有设置,则需要先获得监视器锁,然后开始执行方法,方法执行之后再释放监视器锁.这时如果其他线程来请求执行方法,会因为无法获得监视器锁而被阻断住.值得注意的是,如果在方法执行过程中,发生了异常,并且方法内部并没有处理该异常,那么在异常被抛到方法外面之前监视器锁会被自动释放</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>同步代码块使用monitorenter和monitorexit两个指令实现.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于这两个指令的介绍：<br>&emsp;&emsp;大致内容如下：可以把执行monitorenter指令理解为加锁,执行monitorexit理解为释放锁.每个对象维护着一个记录着被锁次数的计数器.未被锁定的对象的该计数器为0,当一个线程获得锁(执行monitorenter)后,该计数器自增变为1,当同一个线程再次获得该对象的锁的时候,计数器再次自增.当同一个线程释放锁(执行monitorexit指令)的时候,计数器再自减.当计数器为0的时候,锁将被释放,其他线程便可以获得锁</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁.当线程要执行的方法被标注上ACC_SYNCHRONIZED时,需要先获得锁才能执行该方法<br>&emsp;&emsp;同步代码块通过monitorenter和monitorexit执行来进行加锁.当线程执行到monitorenter的时候要先获得所锁,才能执行后面的方法.当线程执行到monitorexit的时候则要释放锁<br>&emsp;&emsp;每个对象自身维护这一个被加锁次数的计数器,当计数器数字为0时表示可以被任意线程获得锁.当计数器不为0时,只有获得锁的线程才能再次获得锁.即可重入锁<br>&emsp;&emsp;无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的,在Java虚拟机(HotSpot)中,Monitor是基于C++实现的,由ObjectMonitor实现<br>&emsp;&emsp;ObjectMonitor类中提供了几个方法,如enter、exit、wait、notify、notifyAll等.sychronized加锁的时候,会调用objectMonitor的enter方法,解锁的时候会调用exit方法(关于Monitor详见<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程(四)—— Moniter的实现原理</a>)</p>
<h2 id="synchronized和原子性、可见性、有序性之间的关系"><a href="#synchronized和原子性、可见性、有序性之间的关系" class="headerlink" title="synchronized和原子性、可见性、有序性之间的关系"></a>synchronized和原子性、可见性、有序性之间的关系</h2><h3 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h3><p>&emsp;&emsp;原子性是指一个操作是不可中断的,要全部执行完成,要不就都不执行<br>&emsp;&emsp;线程是CPU调度的基本单位.CPU有时间片的概念,会根据不同的调度算法进行线程调度.当一个线程获得时间片之后开始执行,在时间片耗尽之后,就会失去CPU使用权.所以在多线程场景下,由于时间片在线程间轮换,就会发生原子性问题<br>&emsp;&emsp;在Java中,为了保证原子性,提供了两个高级的字节码指令monitorenter和monitorexit.前面中介绍过,这两个字节码指令,在Java中对应的关键字就是synchronized<br>&emsp;&emsp;通过monitorenter和monitorexit指令,可以保证被synchronized修饰的代码在同一时间只能被一个线程访问,在锁未释放之前,无法被其他线程访问到.因此在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的  </p>
<blockquote>
<p>线程1在执行monitorenter指令的时候,会对Monitor进行加锁,加锁后其他线程无法获得锁,除非线程1主动解锁.即使在执行过程中,由于某种原因,比如CPU时间片用完,线程1放弃了CPU,但是他并没有进行解锁.而由于synchronized的锁是可重入的,下一个时间片还是只能被他自己获取到,还是会继续执行代码.直到所有代码执行完.这就保证了原子性</p>
</blockquote>
<h3 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h3><p>可见性是指当多个线程访问同一个变量时,一个线程修改了这个变量的值,其他线程能够立即看得到修改的值</p>
<p>&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存,线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝,线程对变量的所有操作都必须在工作内存中进行,而不能直接读写主内存.不同的线程之间也无法直接访问对方工作内存中的变量,线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行.所以就可能出现线程1改了某个变量的值,但是线程2不可见的情况<br>&emsp;&emsp;前面我们介绍过,被synchronized修饰的代码,在开始执行时会加锁,执行完成后会进行解锁.而为了保证可见性,有一条规则是这样的：对一个变量解锁之前,必须先把此变量同步回主存中.这样解锁后,后续线程就可以访问到被修改后的值<br>所以synchronized关键字锁住的对象,其值是具有可见性的</p>
<h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行</p>
<p>&emsp;&emsp;在Java内存模型中分析过：除了引入了时间片以外,由于处理器优化和指令重排等,CPU还可能对输入代码进行乱序执行,比如load-&gt;add-&gt;save有可能被优化成load-&gt;save-&gt;add.这就是可能存在有序性问题<br>&emsp;&emsp;这里需要注意的是：synchronized是无法禁止指令重排和处理器优化的.也就是说,synchronized无法避免上述提到的问题  </p>
<p>为什么还说synchronized也提供了有序性保证呢?<br>&emsp;&emsp;这就要再把有序性的概念扩展一下了.Java程序中天然的有序性可以总结为一句话：如果在本线程内观察,所有操作都是天然有序的.如果在一个线程中观察另一个线程,所有操作都是无序的<br>&emsp;&emsp;这其实和as-if-serial语义有关;as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度),单线程程序的执行结果都不能被改变.编译器和处理器无论如何优化,都必须遵守as-if-serial语义<br>&emsp;&emsp;简单说就是：as-if-serial语义保证了单线程中,指令重排是有一定的限制的,而只要编译器和处理器都遵守了这个语义,那么就可以认为单线程程序是按照顺序执行的.当然实际上还是有重排的,只不过我们无须关心这种重排的干扰<br>&emsp;&emsp;所以呢由于synchronized修饰的代码,同一时间只能被同一线程访问.那么也就是单线程执行的.所以可以保证其有序性</p>
<h2 id="synchronized与锁优化"><a href="#synchronized与锁优化" class="headerlink" title="synchronized与锁优化"></a>synchronized与锁优化</h2><p>任何对象都可以作为锁,那么锁信息又存在对象的什么地方?–存在对象头中<br>对象头中的信息:</p>
<ul>
<li>Mark Word:存的是对象的hash值、锁信息等(虚拟机团队为了提高空间利用率,定义了几个锁的标志位,根据不同的锁标志位存储不同的状态信息,即MarkWord空间利用率是非常高的)</li>
<li>Class Metadata Address</li>
<li>Array Length</li>
</ul>
<p>&emsp;&emsp;synchronized其实是借助Monitor实现的,在加锁时会调用objectMonitor的enter方法,解锁的时候会调用exit方法.事实上只有在JDK1.6之前,synchronized的实现才会直接调用ObjectMonitor的enter和exit,这种锁被称之为重量级锁<br>&emsp;&emsp;在JDK1.6中出现对锁进行了很多的优化,进而出现轻量级锁、偏向锁、锁消除、适应性自旋锁、锁粗化(自旋锁在1.4就有,只不过默认的是关闭的,jdk1.6是默认开启的),这些操作都是为了在线程之间更高效的共享数据,解决竞争问题<br>关于自旋锁、锁粗化和锁消除可以参考<a href="http://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">深入理解多线程(五)—— Java虚拟机的锁优化技术</a></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>&emsp;&emsp;每次获取锁和释放锁会浪费资源,性能不高<br>&emsp;&emsp;很多情况下,竞争锁不是由多个线程,而是由一个线程在使用.相当于单线程在访问,每次像多线程获取资源会浪费资源,于是就有了偏向锁  </p>
<ul>
<li>比如第一个线程过来了,就找对象头查一下看是不是偏向锁,偏向锁的对象头会记录(线程id、Epoch、对象的分代年龄信息、是否是偏向锁、锁标志位)</li>
<li>然后就再查看线程id,第一次需要获取锁对象后不释放,后面发现线程id一致就直接进,没有锁的获取和释放过程;锁毕竟不是单个线程在运行,肯定是多个线程的情况下运行,偏向锁获取了之后就一直没有撤销</li>
</ul>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他锁尝试竞争偏向锁的时候持有偏向锁的线程才会去释放偏向锁<br>偏向锁的使用场景是只有一个线程访问同步代码块的场景</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>&emsp;&emsp;可以同时让多个线程进入同步代码块中,同时都能获取锁<br>&emsp;&emsp;轻量级锁是如何加锁的?在线程执行同步代码块前,java虚拟机会先在当前线程的栈帧中创建用于锁记录的空间,并将对象头中的MarkWord复制到锁记录空间,然后开始竞争锁,当竞争成功后,MarkWord就会把锁标志位改成轻量级锁,接着执行同步体<br>&emsp;&emsp;比如多个线程一块访问,一个获取了轻量级锁,另外一个需要等待执行,它也要复制MarkWord到虚拟机栈中,接着她要修改MarkWord,发现被别的线程获得了锁,它修改不成功,就不停的去修改,不停的失败,直到前面的线程将锁给释放了,于是它可以获得了,上述的过程就是<font color='red'>自旋</font>锁<br>&emsp;&emsp;当第一个线程执行完毕后,第二个线程获取到之后就把锁升级成重量级锁,线程就会阻塞,当第一个线程执行完毕释放锁并唤醒第二个线程,接着第二个线程开始继续执行,这就是轻量级锁的执行过程</p>
<h2 id="synchronized和lock之间的关系"><a href="#synchronized和lock之间的关系" class="headerlink" title="synchronized和lock之间的关系"></a>synchronized和lock之间的关系</h2><h2 id="不使用synchronized如何实现一个线程安全的单例"><a href="#不使用synchronized如何实现一个线程安全的单例" class="headerlink" title="不使用synchronized如何实现一个线程安全的单例"></a>不使用synchronized如何实现一个线程安全的单例</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/08-synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/09-volatile%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>volatile原理和使用</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/03-%E9%9B%86%E5%90%88%E7%AF%87/Fail-Fast%E6%9C%BA%E5%88%B6/"><img class="next_cover lazyload" data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>fail-fast机制</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/01-聊聊并发/" title="聊聊并发"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">聊聊并发</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/03-线程池/" title="线程池"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">线程池</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/04-Java内存模型JMM/" title="JAVA内存模型"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">JAVA内存模型</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/07-线程通信/" title="线程通信"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">线程通信</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/05-线程安全/" title="线程安全"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">线程安全</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/09-volatile原理和使用/" title="volatile原理和使用"><img class="relatedPosts_cover lazyload"data-src="https://ftp.bmp.ovh/imgs/2019/11/016bafaee7cd7aa4.png"><div class="relatedPosts_title">volatile原理和使用</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>