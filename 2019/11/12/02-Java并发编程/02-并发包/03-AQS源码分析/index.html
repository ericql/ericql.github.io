<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>03-AQS源码分析 | Eric Liang</title><meta name="description" content="AQS源码分析"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="03-AQS源码分析"><meta name="twitter:description" content="AQS源码分析"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?aqs"><meta property="og:type" content="article"><meta property="og:title" content="03-AQS源码分析"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/03-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="AQS源码分析"><meta property="og:image" content="https://source.unsplash.com/300x300/?aqs"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/03-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="prev" title="06-可重入读写锁ReentrantReadWriteLock源码解析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/06-%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="next" title="08-线程通信Condition源码解析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/08-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#AbstractQueuedSynchronizer源码分析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">AbstractQueuedSynchronizer源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#简介"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Node类解析"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Node类解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ConditionObject类解析"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">ConditionObject类解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AQS成员变量"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">AQS成员变量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#共享资源与同步队列"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">共享资源与同步队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS支持变量"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">CAS支持变量</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AQS操作解析"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">AQS操作解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AQS独占方式解析"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">AQS独占方式解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#acquire获取资源"><span class="toc_mobile_items-number">1.5.1.1.</span> <span class="toc_mobile_items-text">acquire获取资源</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#tryAcquire方法"><span class="toc_mobile_items-number">1.5.1.1.1.</span> <span class="toc_mobile_items-text">tryAcquire方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#addWaiter"><span class="toc_mobile_items-number">1.5.1.1.2.</span> <span class="toc_mobile_items-text">addWaiter()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#acquireQueued"><span class="toc_mobile_items-number">1.5.1.1.3.</span> <span class="toc_mobile_items-text">acquireQueued()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#acquire流程总结"><span class="toc_mobile_items-number">1.5.1.1.4.</span> <span class="toc_mobile_items-text">acquire流程总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#release释放资源"><span class="toc_mobile_items-number">1.5.1.2.</span> <span class="toc_mobile_items-text">release释放资源</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#1-tryRelease尝试释放"><span class="toc_mobile_items-number">1.5.1.2.1.</span> <span class="toc_mobile_items-text">1.tryRelease尝试释放</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#2-unparkSuccessor"><span class="toc_mobile_items-number">1.5.1.2.2.</span> <span class="toc_mobile_items-text">2.unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AQS共享方式解析"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">AQS共享方式解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#acquireShared-int"><span class="toc_mobile_items-number">1.5.2.1.</span> <span class="toc_mobile_items-text">acquireShared(int)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#1-tryAcquireShared"><span class="toc_mobile_items-number">1.5.2.1.1.</span> <span class="toc_mobile_items-text">1.tryAcquireShared</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#2-doAcquireShared"><span class="toc_mobile_items-number">1.5.2.1.2.</span> <span class="toc_mobile_items-text">2.doAcquireShared</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#releaseShared"><span class="toc_mobile_items-number">1.5.2.2.</span> <span class="toc_mobile_items-text">releaseShared</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#1-doReleaseShared"><span class="toc_mobile_items-number">1.5.2.2.1.</span> <span class="toc_mobile_items-text">1.doReleaseShared</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AbstractQueuedSynchronizer源码分析"><span class="toc-number">1.</span> <span class="toc-text">AbstractQueuedSynchronizer源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node类解析"><span class="toc-number">1.2.</span> <span class="toc-text">Node类解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConditionObject类解析"><span class="toc-number">1.3.</span> <span class="toc-text">ConditionObject类解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS成员变量"><span class="toc-number">1.4.</span> <span class="toc-text">AQS成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享资源与同步队列"><span class="toc-number">1.4.1.</span> <span class="toc-text">共享资源与同步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS支持变量"><span class="toc-number">1.4.2.</span> <span class="toc-text">CAS支持变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS操作解析"><span class="toc-number">1.5.</span> <span class="toc-text">AQS操作解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS独占方式解析"><span class="toc-number">1.5.1.</span> <span class="toc-text">AQS独占方式解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquire获取资源"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">acquire获取资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tryAcquire方法"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">tryAcquire方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addWaiter"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">addWaiter()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#acquireQueued"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">acquireQueued()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#acquire流程总结"><span class="toc-number">1.5.1.1.4.</span> <span class="toc-text">acquire流程总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#release释放资源"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">release释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-tryRelease尝试释放"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">1.tryRelease尝试释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-unparkSuccessor"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">2.unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS共享方式解析"><span class="toc-number">1.5.2.</span> <span class="toc-text">AQS共享方式解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireShared-int"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">acquireShared(int)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-tryAcquireShared"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">1.tryAcquireShared</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-doAcquireShared"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">2.doAcquireShared</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseShared"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">releaseShared</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-doReleaseShared"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">1.doReleaseShared</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">03-AQS源码分析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-05</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/">02-并发包</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="AbstractQueuedSynchronizer源码分析"><a href="#AbstractQueuedSynchronizer源码分析" class="headerlink" title="AbstractQueuedSynchronizer源码分析"></a>AbstractQueuedSynchronizer源码分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;AbstractQueuedSynchronizer(下文均以AQS代替)可以用于构建锁或者其他相关同步装置的基础框架.JDK1.5之前一般使用synchronized关键字来实现线程对共享变量的互斥访问,而JDK1.5之后开发了AQS组件,使用原生java代码实现了synchronized语义.<br>&emsp;&emsp;AQS实现了两种模式：公平模式和非公平模式,在我们实现自定义锁的时候(后续会自己实现锁)只需按照要求即可实现对应模式或两种模式都实现,ReentrantLock就是实现了上述两种模式的锁<br>&emsp;&emsp;在使用公平模式时,AQS会生成一个FIFO队列,严格按照线程挂起顺序获得锁使用权.或者说AQS提供了FIFO队列<br>&emsp;&emsp;AQS内部包含了两个内部类,可以先从这个简单的内部类开始解析  </p>
<h2 id="Node类解析"><a href="#Node类解析" class="headerlink" title="Node类解析"></a>Node类解析</h2><p>&emsp;&emsp;Node是用来构成FIFO队列的基本单元,当前线程获取同步状态失败后,AQS会将当前线程以及等待状态等信息构造成节点并加入到同步队列中,同时会阻塞当前线程,当同步状态释放后,会把首节点的线程唤醒,使其再次尝试获取同步状态<br>&emsp;&emsp;它是用来保存获取同步状态失败的线程引用和线程状态、等待状态以及前驱和后继节点的容器,用来实现线程阻塞.<br>具体代码解析如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** static类的属性 */</span></span><br><span class="line">	<span class="comment">/** 指示节点在共享模式下等待的标记 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">	<span class="comment">/** 指示节点在独占模式下等待的标记 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** waitStatus值以指示线程已取消 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/** waitStatus 值以指示后续线程需要 unparking */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/** waitStatus 值以指示线程正在等待条件 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * waitStatus 值以指示下一个 acquireShared 应无条件传播</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 表示节点的状态字段.仅接受以下值:</span></span><br><span class="line"><span class="comment">	 *   SIGNAL: 值为-1,线程的后继线程正/已被阻塞处于等待状态,</span></span><br><span class="line"><span class="comment">	 * 			当该线程释放了同步状态或取消时,将会通知后继节点,</span></span><br><span class="line"><span class="comment">	 *			使后继节点的线程得以运行(unpark)</span></span><br><span class="line"><span class="comment">	 *   CANCELLED: 值为1,由于在同步队列中等待的线程等待超时或者被中断</span></span><br><span class="line"><span class="comment">	 *			需要从同步队列中取消等待,节点进入该状态不会变化</span></span><br><span class="line"><span class="comment">	 *   CONDITION: 值为-2,节点在等待队列中,节点线程等待在Condition上,</span></span><br><span class="line"><span class="comment">	 * 			当其他线程对Condition调用了singal方法后,该节点将会从等待队列中</span></span><br><span class="line"><span class="comment">	 * 			转移到同步队列中,加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">	 *   PROPAGATE: 值为-3,表示下一次共享模式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">	 *   INITIAL: 初始状态值为0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链接到前驱节点,当前节点/线程依赖它来检查waitStatus</span></span><br><span class="line"><span class="comment">	 * 在入同步队列时被设置,并且仅在移除同步队列时才归零(便于GC)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链接到后继节点,当前节点/线程释放时释放.在入同步队列期间分配</span></span><br><span class="line"><span class="comment">	 * 在绕过取消的前驱节点时调整,并在出同步队列时取消</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将节点入列的线程,构造时初始化,使用后清零</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链接到下一个节点等待条件,或者特殊值SHARED</span></span><br><span class="line"><span class="comment">	 * 因为条件队列只有在保持在独占模式时才会被访问</span></span><br><span class="line"><span class="comment">	 * 所以只需要一个简单的链接队列来保持节点,同时等待条件</span></span><br><span class="line"><span class="comment">	 * 然后将它们转移到队列中以重新获取.并且因为条件只能是排它的</span></span><br><span class="line"><span class="comment">	 * 我们通过使用特殊的值来指示共享模式来保持一个字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Node nextWaiter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果节点在共享模式下等待,则返回true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回上一个节点,为null则抛出NullPointerException</span></span><br><span class="line"><span class="comment">	 * 当前驱节点不为null时使用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">		Node p = prev;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于建立初始头或共享标记</span></span><br><span class="line">	Node() &#123;    </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由addWaiter使用</span></span><br><span class="line">	Node(Thread thread, Node mode) &#123;     </span><br><span class="line">		<span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">		<span class="keyword">this</span>.thread = thread;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由Condition使用</span></span><br><span class="line">	Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; </span><br><span class="line">		<span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">		<span class="keyword">this</span>.thread = thread;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConditionObject类解析"><a href="#ConditionObject类解析" class="headerlink" title="ConditionObject类解析"></a>ConditionObject类解析</h2><p>&emsp;&emsp;已在Condiiton源码解析中阐述,如有需要请看<a href="https://ericql.github.io/2018/08/30/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">ConditionObject类解析连接</a><br>&emsp;&emsp;AQS的内部类Node和ConditionObject已经解析完毕,接下来解析AQS的成员变量,基础部分就解析完毕,就可以各种AQS相关的操作流程  </p>
<h2 id="AQS成员变量"><a href="#AQS成员变量" class="headerlink" title="AQS成员变量"></a>AQS成员变量</h2><h3 id="共享资源与同步队列"><a href="#共享资源与同步队列" class="headerlink" title="共享资源与同步队列"></a>共享资源与同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列的head,懒加载  </span></span><br><span class="line"><span class="comment"> * 除了初始化之外只能通过setHead来设置</span></span><br><span class="line"><span class="comment"> * 如果head存在,则它的waitStatus保证不是CANCELLED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列的tail,懒加载.</span></span><br><span class="line"><span class="comment"> * 只能通过enq()方法或新增新节点的方式改变tail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由上概述的成员变量可知:AQS维护了volatile int state(代表共享资源,同步器的状态值,如:1-已占有,0-未占有,&gt;1-表示重入的数量)和一个FIFO线程等待队列;AQS使用了state状态位+FIFO排列方式记录了锁的获取和释放<br><img alt="共享资源+等待队列图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/AQS/AQS%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E4%B8%8E%E9%98%9F%E5%88%97.jpg?raw=true" class="lazyload"><br>state的访问方式主要是以下三种:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回同步状态的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置同步状态的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">	state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值=期望值,则原子性的将同步状态设置为给定更新值</span></span><br><span class="line"><span class="comment"> * 成功则返回true,失败则表示当前实际值不等于期望值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS支持变量"><a href="#CAS支持变量" class="headerlink" title="CAS支持变量"></a>CAS支持变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了支持compareAndSet,我们需要在AQS中实现这一点:</span></span><br><span class="line"><span class="comment"> * 但是为了后期的增强,我们不用显示子类AtomicInteger,虽然它是有效和有用的</span></span><br><span class="line"><span class="comment"> * 作为迷你实现,我们原生的实现CAS的常用API,</span></span><br><span class="line"><span class="comment"> * 我们在处理的同时,对CASable字段执行相同操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br></pre></td></tr></table></figure>
<p>内部类和成员变量等基础解析完毕,接下来就是AQS操作:</p>
<h2 id="AQS操作解析"><a href="#AQS操作解析" class="headerlink" title="AQS操作解析"></a>AQS操作解析</h2><p><img alt="AQS类结构图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/AQS/AQS%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true" class="lazyload"><br>&emsp;&emsp;由上图可知:AQS实现了两种资源共享方式:独占模式+共享模式,独占对外提供的方法是acquire-release;共享对外提供方法是acquireShared-releaseShared;接下来分别就这两种方式进行阐述</p>
<h3 id="AQS独占方式解析"><a href="#AQS独占方式解析" class="headerlink" title="AQS独占方式解析"></a>AQS独占方式解析</h3><h4 id="acquire获取资源"><a href="#acquire获取资源" class="headerlink" title="acquire获取资源"></a>acquire获取资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以独占模式获取共享资源,忽略中断</span></span><br><span class="line"><span class="comment"> * 通过至少调用一次tryAcquire来实现,若成功则返回;</span></span><br><span class="line"><span class="comment"> * 否则线程将进入队列排队,可能会反复阻塞和解除阻塞,直到tryAcquire直到成功</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法可用于实现Lock锁的lock方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="acquire流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/AQS/Acquire%E6%B5%81%E7%A8%8B.jpg?raw=true" class="lazyload"></p>
<h5 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h5><p>&emsp;&emsp;此方法尝试获取资源,AQS中代码如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;AQS中的tryAcquire方法直接抛出异常,并没有实现具体的功能,具体的功能交给具体自定义同步器去实现了.<br>&emsp;&emsp;注意:此处并没有定义成abstract,因为AQS内部实现了独占模式和共享模式,不定义成abstract,自定义同步器可根据自己需求单独实现其中一种或两种都实现<br>如JDK内部的ReentrantLock已经使用FairSync和NonFairSync这两种方式帮我们实现了tryAcquire<br>FairSync的tryAcquire:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取独占锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 为0意味着锁没有被任何线程所拥有</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 若锁没有被任何线程所拥有,则判断当前线程是否是CLH队列中的第一个线程,</span></span><br><span class="line">    	<span class="comment">// 若是的话,则获取该锁,设置锁的状态,并设置锁的拥有者为当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    	<span class="comment">// 若独占锁拥有者已经为当前线程—重入,则更新锁的状态</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NonFairSync的tryAcquire:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; </span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h5><p>&emsp;&emsp;当tryAcquire尝试去获取锁的时候成功则返回true,失败则返回false;此时!tryAcquire就是true就会往下执行acquireQueued(addWaiter())<br>&emsp;&emsp;addWaiter(Node.EXCLUSIVE)的作用:创建”当前线程”的Node节点,且Node中记录”当前线程”对应的锁是”独占锁”类型,并且该节点添加到CLH队列的末尾  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 新建一个Node节点,节点对应的线程是"当前线程","当前线程"的锁的模型是mode</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  </span><br><span class="line">    Node pred = tail;  </span><br><span class="line">    <span class="comment">// 若CLH队列不为空,则将"当前线程"添加到CLH队列末尾  </span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line">            pred.next = node;  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 若CLH队列为空,则调用enq()新建CLH队列,然后再将”当前线程”添加到CLH队列中。  </span></span><br><span class="line">    enq(node);  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compareAndSetTail也属于CAS函数,也是通过”本地方法”实现的compareAndSetTail(expect, update)会以原子的方式进行操作,它的作用是判断CLH队列的队尾是不是为expect,是的话就将队尾设为update</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq()的作用很简单,如果CLH队列为空,则新建一个CLH表头;然后将node添加到CLH末尾,否则直接将node添加到CLH末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        Node t = tail;  </span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  </span><br><span class="line">                tail = head;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            node.prev = t;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">                t.next = node;  </span><br><span class="line">                <span class="keyword">return</span> t;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h5><p>&emsp;&emsp;我们已经将当期线程添加到CLH队列中了.而acquireQueued的作用就是逐步的去执行CLH队列的线程,如果当前线程获取到了锁则返回,否则当前线程休眠直到唤醒并重新获取锁才返回;获取过程中head、tail不断移动将已经完成的队列节点清除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  <span class="comment">// 标志是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// interrupted表示在CLH队列的调度中,"当前线程"在休眠时,有没有被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">		<span class="comment">// 自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="comment">// 获取上一个节点.node是"当前线程"对应的节点,这里就意味着”获取上一个等待锁的线程”</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">			<span class="comment">// 如果前驱节点是head,该节点则是阻塞的第一个节点,可以尝试去获取资源(前驱唤醒或interrupt)</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">				<span class="comment">// 获取到资源后将head指向该节点;即head指向节点是获取资源的节点或null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">				<span class="comment">// p的prev和next都被设置为null,方便GC将head之前的节点,即拿完资源节点全部出队  </span></span><br><span class="line">                p.next = <span class="keyword">null</span>; </span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;  </span><br><span class="line">			<span class="comment">// 如果可以休息了,就进入waiting状态,直到被unpark()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">				<span class="comment">// waiting状态被interrupt的,在标记中断为true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.shouldParkAfterFailedAcquire<br>&emsp;&emsp;此方法检测和更新获取失败节点的状态,避免存在节点是取消或被中断了,确保当前节点是真的可以park了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查和更新获取资源失败的节点状态</span></span><br><span class="line"><span class="comment"> * 如果线程阻塞则返回true </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 前驱节点已经设置了通知信号状态,Node节点可以休息</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 前驱节点被取消了,跳过被取消节点,让上上节点与当前节点连接</span></span><br><span class="line"><span class="comment">	* 一直循环往前找,直到有waitStatus状态正常等待,就把当前节点与之连接</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			node.prev = pred = pred.prev;</span><br><span class="line">		&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">		pred.next = node;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 当waitStatus状态是0或PROPAGATE,将前驱的状态设置为SIGNAL信号</span></span><br><span class="line"><span class="comment">		 * 告诉它拿完号通知下自己,也可能会失败</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.parkAndCheckInterrupt()<br>&emsp;&emsp;真正让线程进入waiting状态,进行park的操作;并进行检查中断的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 调用park()使线程进入waiting状态</span></span><br><span class="line">	LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 如果被唤醒查看是不是被中断了</span></span><br><span class="line">	<span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parkAndCheckInterrupt()的作用是阻塞当前线程,并且返回”线程被唤醒之后”的中断状态.它会先通过LockSupport.park()阻塞”当前线程”,然后通过Thread.interrupted()返回线程的中断状态  </p>
<p>线程被阻塞之后如何唤醒:<br>第1种情况：unpark()唤醒.”前继节点对应的线程”使用完锁之后,通过unpark()方式唤醒当前线程<br>第2种情况：中断唤醒.其它线程通过interrupt()中断当前线程</p>
<p>补充: LockSupport()中的park(),unpark()的作用 和 Object中的wait(),notify()作用类似,是阻塞/唤醒;它们的用法不同,park(),unpark()是轻量级的,而wait(),notify()是必须先通过Synchronized获取同步锁<br>3.acquireQueue的流程图<br><img alt="acquireQueue的流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/AQS/AcquireQueue.jpg?raw=true" class="lazyload"></p>
<h5 id="acquire流程总结"><a href="#acquire流程总结" class="headerlink" title="acquire流程总结"></a>acquire流程总结</h5><p>1.调用tryAcquire()尝试去获取资源,成功则返回<br>2.失败则addWaiter将线程对应节点放到队列尾部,并标记为独占模式,<br>3.acquireQueued是不是第一个在等待的,是就再尝试获取,不行就去休息<br>4.等待过程如果被中断,它不响应,等待获取资源即当前线程在活跃后再去处理<br><img alt="acquire的流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/AQS/Acquire.jpg?raw=true" class="lazyload"></p>
<h4 id="release释放资源"><a href="#release释放资源" class="headerlink" title="release释放资源"></a>release释放资源</h4><p>&emsp;&emsp;独占模式下资源的释放,也是Lock锁的unlock的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占模式下进行资源释放  </span></span><br><span class="line"><span class="comment"> * true则释放一个或多个线程来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">		Node h = head;</span><br><span class="line">		<span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-tryRelease尝试释放"><a href="#1-tryRelease尝试释放" class="headerlink" title="1.tryRelease尝试释放"></a>1.tryRelease尝试释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样此处也是直接抛出异常的,具体代码由实现类去实现,可参考ReentrantLock的Sync,已经重写了tryRelease,具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 状态值-1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">	<span class="comment">// 当前线程与锁持有的线程不一致则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// c==0则所有的锁都unlock,将free置为true,独占锁置为null</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-unparkSuccessor"><a href="#2-unparkSuccessor" class="headerlink" title="2.unparkSuccessor"></a>2.unparkSuccessor</h5><p>&emsp;&emsp;若释放锁成功后,遍历节点将需要取消的取消,然后再次尾部开始查找最前边的未取消的节点并进行唤醒,尝试争夺资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//如果waitStatus &lt; 0 则将当前节点清零</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若后续节点为空或已被cancel，则从尾部开始找到队列中最前边的waitStatus&lt;=0，即未被cancel的节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用unpark()唤醒队列最前边的未放弃的节点,就会去执行acquire()去尝试获取资源,它已经队列最前边的未放弃节点了,即它已经在占用节点后面的第一个等待节点了,即使这一次获取失败也会前驱节点设置为SIGNAL,然后下次就会获取成功</p>
<h3 id="AQS共享方式解析"><a href="#AQS共享方式解析" class="headerlink" title="AQS共享方式解析"></a>AQS共享方式解析</h3><h4 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h4><p>&emsp;&emsp;共享模式下获取资源的方法,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下获取资源,不响应中断  </span></span><br><span class="line"><span class="comment"> * 期间至少要调用一次tryAcquireShared,成功则返回,否则线程被阻塞</span></span><br><span class="line"><span class="comment"> * 可能反复阻塞和解阻塞直到成功  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">		doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-tryAcquireShared"><a href="#1-tryAcquireShared" class="headerlink" title="1.tryAcquireShared"></a>1.tryAcquireShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下尝试获取资源</span></span><br><span class="line"><span class="comment"> * 这方法前提得查询对象是否允许在共享模式中获取它</span></span><br><span class="line"><span class="comment"> * 成功则返回,失败则对线程节点进行排队,直到收到SIGNAL信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;又看到直接抛出异常的方法,大家应该知道此方法肯定是由实现类去具体实现了,这里后续每一个实现类都会进行源码分析,咱后续再讨论;<br>该方法已经明确了返回值:   </p>
<ul>
<li>失败则返回负值  </li>
<li>在共享模式下获取成功,但是没有后续资源可以获取则返回0  </li>
<li>在共享模式下获取成功,并且后续获取资源也成功则返回正值,这种情况下,后续等待线程必须检查可用性    </li>
</ul>
<h5 id="2-doAcquireShared"><a href="#2-doAcquireShared" class="headerlink" title="2.doAcquireShared"></a>2.doAcquireShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在共享不中断模式下获取资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 加入队列尾部</span></span><br><span class="line">	<span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">	<span class="comment">// 是否成功标志</span></span><br><span class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 等待过程是否被中断标志</span></span><br><span class="line">		<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">// 获取到前驱节点</span></span><br><span class="line">			<span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">// 前驱节点是head,则当前节点可以通过head唤醒,从而去获取资源</span></span><br><span class="line">			<span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">				<span class="comment">// 尝试获取资源</span></span><br><span class="line">				<span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">				<span class="comment">// 获取成功</span></span><br><span class="line">				<span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 将head指向自己,并进行传播(还有资源可供后面线程唤醒使用)</span></span><br><span class="line">					setHeadAndPropagate(node, r);</span><br><span class="line">					p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">					<span class="comment">// 此处处理中断</span></span><br><span class="line">					<span class="keyword">if</span> (interrupted)</span><br><span class="line">						selfInterrupt();</span><br><span class="line">					failed = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断状态,寻找可以park点进行waiting</span></span><br><span class="line">			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">				parkAndCheckInterrupt())</span><br><span class="line">				interrupted = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (failed)</span><br><span class="line">			cancelAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与acquireQueued()唯一区别是中断处理操作selfIntertupt()放到doAcquireShared()里面,而前面的独占模式acquireQueued则是放在外面最后处理;即acquireQueued是先拿到资源后判断中断,而共享模式是在拿资源的过程中可以中断以便以后线程可以获取资源,关键就在于拿资源过程中是否可以被抢占<br>&emsp;&emsp;与独占模式相比,共享模式下必须是head节点后面的第一个等待节点去获取,共享资源有剩余的情况下就会去唤醒其他线程节点;而独占模式下,同一时刻只有一个线程在执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置队列的head节点,并在共享模式下检查后继节点是否在等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">	Node h = head; <span class="comment">// 记录之前的head节点</span></span><br><span class="line">	setHead(node); <span class="comment">// 设置头节点</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果还有剩余量或h为null或h被取消/被中断则唤醒下一个线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">		(h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		Node s = node.next;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">			doReleaseShared();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在共享模式下释放资源  </span></span><br><span class="line"><span class="comment"> * 通过解除阻塞一个或多个线程来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放资源</span></span><br><span class="line">	<span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">		<span class="comment">// 唤醒后继节点</span></span><br><span class="line">		doReleaseShared();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即先释放掉资源后唤醒后继,与独占模式下release一致,但是独占模式下tryRelease在完全释放掉资源后才会去唤醒其他节点,主要是独占下可重入的问题,而共享模式下则是控制一定量线程并发执行,拥有这些资源的线程释放部分资源就可以唤醒后继节点<br>&emsp;&emsp;tryReleaseShared同样是抛出异常方式,需要实现类去实现的</p>
<h5 id="1-doReleaseShared"><a href="#1-doReleaseShared" class="headerlink" title="1.doReleaseShared"></a>1.doReleaseShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下的释放动作 -- 唤醒后继和确保传递</span></span><br><span class="line"><span class="comment"> * 说明: 在独占模式下,如果Signal则释放仅仅是调用unparkSuccessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		Node h = head;</span><br><span class="line">		<span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">			<span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">			<span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">					<span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">				unparkSuccessor(h);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">					 !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/03-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/03-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?aqs" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/06-%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?read" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>06-可重入读写锁ReentrantReadWriteLock源码解析</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/08-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?condition" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>08-线程通信Condition源码解析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/11-并发工具类CyclicBarrier源码解析/" title="11-并发工具类CyclicBarrier源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cyclic"><div class="relatedPosts_title">11-并发工具类CyclicBarrier源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/12-ConcurrentLinkedQueue/" title="12-ConcurrentLinkedQueue"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?queue"><div class="relatedPosts_title">12-ConcurrentLinkedQueue</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/03-线程安全/" title="线程安全"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?security"><div class="relatedPosts_title">线程安全</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/07-Java内存模型JMM/" title="JAVA内存模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?beauty"><div class="relatedPosts_title">JAVA内存模型</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/08-Java重排序和顺序一致性模型/" title="Java重排序和顺序一致性模型"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?nature"><div class="relatedPosts_title">Java重排序和顺序一致性模型</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>