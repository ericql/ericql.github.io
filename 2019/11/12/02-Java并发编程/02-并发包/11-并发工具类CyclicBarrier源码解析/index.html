<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>11-并发工具类CyclicBarrier源码解析 | Eric Liang</title><meta name="description" content="并发工具类CyclicBarrier源码解析"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="11-并发工具类CyclicBarrier源码解析"><meta name="twitter:description" content="并发工具类CyclicBarrier源码解析"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?cyclic"><meta property="og:type" content="article"><meta property="og:title" content="11-并发工具类CyclicBarrier源码解析"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/11-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="并发工具类CyclicBarrier源码解析"><meta property="og:image" content="https://source.unsplash.com/300x300/?cyclic"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/11-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="prev" title="Optional类" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/04-Java8%E6%96%B0%E7%89%B9%E6%80%A7/Optional%E7%B1%BB/"><link rel="next" title="10-并发工具类CountDownLatch源码解析" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/10-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#并发工具类CyclicBarrier源码解析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">并发工具类CyclicBarrier源码解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#简介"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#源码解析"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">源码解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内部类"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">内部类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#属性"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#构造函数"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">构造函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#breakBarrier"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">breakBarrier</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#dowait"><span class="toc_mobile_items-number">1.2.5.</span> <span class="toc_mobile_items-text">dowait</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getNumberWaiting"><span class="toc_mobile_items-number">1.2.6.</span> <span class="toc_mobile_items-text">getNumberWaiting</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#nextGeneration"><span class="toc_mobile_items-number">1.2.7.</span> <span class="toc_mobile_items-text">nextGeneration</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#示例分析"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">示例分析</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#并发工具类CyclicBarrier源码解析"><span class="toc-number">1.</span> <span class="toc-text">并发工具类CyclicBarrier源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-number">1.2.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">1.2.1.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">1.2.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">1.2.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#breakBarrier"><span class="toc-number">1.2.4.</span> <span class="toc-text">breakBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dowait"><span class="toc-number">1.2.5.</span> <span class="toc-text">dowait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getNumberWaiting"><span class="toc-number">1.2.6.</span> <span class="toc-text">getNumberWaiting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextGeneration"><span class="toc-number">1.2.7.</span> <span class="toc-text">nextGeneration</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例分析"><span class="toc-number">1.3.</span> <span class="toc-text">示例分析</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">11-并发工具类CyclicBarrier源码解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-06</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/">02-并发包</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="并发工具类CyclicBarrier源码解析"><a href="#并发工具类CyclicBarrier源码解析" class="headerlink" title="并发工具类CyclicBarrier源码解析"></a>并发工具类CyclicBarrier源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;CyclicBarrier也是一个同步工具类,字面上意思为可循环的屏障,查看JDK的描述:它允许一组线程相互等待直到所有线程都到达一个公共的屏障点;而这个屏障是可循环的,即在所有的线程释放后这个屏障是可以重新使用的<br>&emsp;&emsp;与CountDownLatch非常相似;不同点在于CountDownLatch维护了一个锁存器计数,当计数达到0后处于wait状态的线程可以执行,而对于CyclicBarrier相当于一个屏障(类似于开会,当所有人都赶到会议室后就开始开会,先来的什么也不干wait),允许一组线程相互等待直到达到某个公共屏障点</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 每一次使用的CyclicBarrier都可以看做Generation的实例</span><br><span class="line"> * 当屏障被触发或重置时,Generation类都会发生改变(主要broken值改变)</span><br><span class="line"> * 可能存在很多线程通过使用barrier从而与Generation类关联</span><br><span class="line"> * 如果发生中断并后续没有复位,则不会有一个处于active状态的Generation</span><br><span class="line"> */</span><br><span class="line">private static class Generation &#123;</span><br><span class="line">	boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：此内部类只有一个broken属性,用来表示屏障是否被损坏状态</p>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** 用于保护屏障的可重入锁 */</span><br><span class="line">private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">/** 设置条件去等待直到屏障失效 */</span><br><span class="line">private final Condition trip = lock.newCondition();</span><br><span class="line">/** 参与线程数量 */</span><br><span class="line">private final int parties;</span><br><span class="line">/* 屏障失效时执行的操作 */</span><br><span class="line">private final Runnable barrierCommand;</span><br><span class="line">/** generation类 */</span><br><span class="line">private Generation generation = new Generation();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 正在等待进入屏障的数量</span><br><span class="line"> * 在每一个Generation进行count down从parties到0</span><br><span class="line"> * 当屏障打破后又0恢复到parties</span><br><span class="line"> */</span><br><span class="line">private int count;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建一个新的CyclicBarrier</span><br><span class="line"> * 当给定数量parties线程都在等待时屏障就会失效</span><br><span class="line"> * 当屏障失效后,就会执行给定的动作,由进入屏障的最后一个线程执行</span><br><span class="line"> */</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">	if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">	this.parties = parties;</span><br><span class="line">	this.count = parties;</span><br><span class="line">	this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建一个新的CyclicBarrier</span><br><span class="line"> * 此处只能指定线程数量,没有指定预先定义的执行动作</span><br><span class="line"> */</span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">	this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="breakBarrier"><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置当前屏障被打破并且唤醒每一个线程</span><br><span class="line"> * 只能被持有锁的线程所调用</span><br><span class="line"> */</span><br><span class="line">private void breakBarrier() &#123;</span><br><span class="line">	generation.broken = true;	// 设置线程状态</span><br><span class="line">	count = parties;			// 恢复初始的等待进入屏障线程数量</span><br><span class="line">	trip.signalAll();			// 唤醒所有线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主屏障代码,内部含有各种策略</span><br><span class="line"> */</span><br><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">	throws InterruptedException, BrokenBarrierException,</span><br><span class="line">		   TimeoutException &#123;</span><br><span class="line">	// 获取锁对象,final表示可用但不可更改(里面还用到Condition)	   </span><br><span class="line">	final ReentrantLock lock = this.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	try &#123;</span><br><span class="line">		// 获取Generation对象</span><br><span class="line">		final Generation g = generation;</span><br><span class="line">		// 屏障已经破坏,则抛出异常</span><br><span class="line">		if (g.broken)</span><br><span class="line">			throw new BrokenBarrierException();</span><br><span class="line">		// 线程被中断</span><br><span class="line">		if (Thread.interrupted()) &#123;</span><br><span class="line">			// 损坏当前屏障,并且唤醒所有线程,只有拥有锁线程才可以调用</span><br><span class="line">			breakBarrier();</span><br><span class="line">			throw new InterruptedException();</span><br><span class="line">		&#125;</span><br><span class="line">		// 等待进入屏障的线程数量递减(dowait使得当前线程进入屏障点)</span><br><span class="line">		int index = --count;</span><br><span class="line">		if (index == 0) &#123;  // 等待进入屏障的线程数量为0,即都已经进入屏障</span><br><span class="line">			// 全部进入后的动作执行标志</span><br><span class="line">			boolean ranAction = false;</span><br><span class="line">			try &#123;</span><br><span class="line">				// 具体需要执行的操作</span><br><span class="line">				final Runnable command = barrierCommand;</span><br><span class="line">				if (command != null)</span><br><span class="line">					command.run(); 	// 执行的动作</span><br><span class="line">				ranAction = true;	// 设置动作执行标志</span><br><span class="line">				// 更新屏障状态并唤醒所有的线程</span><br><span class="line">				nextGeneration();</span><br><span class="line">				return 0;</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				// 出现异常等各种情况,导致ranAction没有运行,则直接打破屏障</span><br><span class="line">				if (!ranAction)</span><br><span class="line">					breakBarrier();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// loop until tripped, broken, interrupted, or timed out</span><br><span class="line">		// 进行自旋操作</span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// 没有设置等待时间</span><br><span class="line">				if (!timed)</span><br><span class="line">					// 等待</span><br><span class="line">					trip.await();</span><br><span class="line">				else if (nanos &gt; 0L) // 设置了等待时间并且大于0</span><br><span class="line">					// 则指定等待时长</span><br><span class="line">					nanos = trip.awaitNanos(nanos);</span><br><span class="line">			&#125; catch (InterruptedException ie) &#123;</span><br><span class="line">				// 如果出现中断异常</span><br><span class="line">				// generation没有改变并且屏障没有打破</span><br><span class="line">				if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">					// 则打破屏障并抛出异常</span><br><span class="line">					breakBarrier();</span><br><span class="line">					throw ie;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// generation已经改变或者屏障已经被打破,则中断线程</span><br><span class="line">					Thread.currentThread().interrupt();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 屏障被损坏,抛出异常</span><br><span class="line">			if (g.broken)</span><br><span class="line">				throw new BrokenBarrierException();</span><br><span class="line">			// 不等于generation,则抛出异常</span><br><span class="line">			if (g != generation)</span><br><span class="line">				// 返回线程数量</span><br><span class="line">				return index;</span><br><span class="line">			// 设置了等待时间,并且等待时间小于0</span><br><span class="line">			if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">				// 损坏屏障抛出异常</span><br><span class="line">				breakBarrier();</span><br><span class="line">				throw new TimeoutException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		// 释放锁</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getNumberWaiting"><a href="#getNumberWaiting" class="headerlink" title="getNumberWaiting"></a>getNumberWaiting</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回在屏障上等待的线程数量</span><br><span class="line"> * 此方法主要用于调试和断言</span><br><span class="line"> */</span><br><span class="line">public int getNumberWaiting() &#123;</span><br><span class="line">	final ReentrantLock lock = this.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	try &#123;</span><br><span class="line">		return parties - count;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 更新屏障打破后的状态并唤醒所有线程</span><br><span class="line"> * 只能被持有资源的线程唤醒</span><br><span class="line"> */</span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">	// 设置当前的generation完成</span><br><span class="line">	trip.signalAll();</span><br><span class="line">	// 重置count</span><br><span class="line">	count = parties;</span><br><span class="line">	generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><p>&emsp;&emsp;以同事聚集开会为例,具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    Random random = new Random();</span><br><span class="line"></span><br><span class="line">    public void meeting(CyclicBarrier barrier) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(4000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; 到达会议室,等待开会.&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发言&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrierDemo demo = new CyclicBarrierDemo();</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;我们开始开会...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    demo.meeting(barrier);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果可知:当Thread0、1、2全部到达会议室后(即调用await)后就会执行CyclicBarrier的barrierAction;之后会继续执行方法,之后执行各线程自己的方法<br>1.当Thread0执行await的流程图如下:<br><img alt="t0await流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/CyclicBarrier/Thread0%E7%9A%84await.jpg?raw=true" class="lazyload"></p>
<blockquote>
<p>说明:ReentrantLock默认使用非公平策略,在dowait调用了NonfairSync.lock;因为一开始的AQS状态为0,所以Thread0可以设置为占用线程,trip.await调用使得线程被添加到条件等待队列上,并被park释放掉资源</p>
</blockquote>
<p>2.Thread1执行await的流程图如下:<br><img alt="t1await流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/CyclicBarrier/Thread1%E7%9A%84await.jpg?raw=true" class="lazyload"></p>
<blockquote>
<p>Thread1也被添加到条件等待队列的尾部,并且被park;</p>
</blockquote>
<p>3.Thread2执行await的流程图如下:<br><img alt="t2await流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/CyclicBarrier/Thread2%E7%9A%84await.jpg?raw=true" class="lazyload"></p>
<blockquote>
<p>当Thread2进来后人员到齐,此时count为0,就会执行barrier中的操作;同时也会把条件等待队列的节点全部signalAll到同步队列中;Thread0线程也会被unpark(),获取到CPU资源继续运行</p>
</blockquote>
<p>Thread0获取到资源后,在AQS的conditionObject方法中就会跳出while循环,执行下放的acquireQueued方法,具体流程图如下:<br><img alt="unpark流程图" data-src="https://github.com/ericql/RoadToJavaArchitecture/blob/master/source/img/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/CyclicBarrier/unpark%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C.jpg?raw=true" class="lazyload"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/11-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/11-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?cyclic" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/04-Java8%E6%96%B0%E7%89%B9%E6%80%A7/Optional%E7%B1%BB/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?beauty" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Optional类</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/10-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BBCountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?countdown" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>10-并发工具类CountDownLatch源码解析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/06-可重入读写锁ReentrantReadWriteLock源码解析/" title="06-可重入读写锁ReentrantReadWriteLock源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?read"><div class="relatedPosts_title">06-可重入读写锁ReentrantReadWriteLock源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/02-Runnable和Callable接口解析/" title="02-Runnable和Callable接口解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?run"><div class="relatedPosts_title">02-Runnable和Callable接口解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/10-并发工具类CountDownLatch源码解析/" title="10-并发工具类CountDownLatch源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?countdown"><div class="relatedPosts_title">10-并发工具类CountDownLatch源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/09-并发工具类Semaphore源码解析/" title="09-并发工具类Semaphore源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?semaphore"><div class="relatedPosts_title">09-并发工具类Semaphore源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/05-ReentrantLock源码解析/" title="05-ReentrantLock源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?lock"><div class="relatedPosts_title">05-ReentrantLock源码解析</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>