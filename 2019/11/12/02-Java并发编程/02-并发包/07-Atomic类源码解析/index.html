<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>07-Atomic类源码解析 | Eric Liang</title><meta name="description" content="Atomic类源码解析"><meta name="keywords" content="Java并发编程"><meta name="author" content="Eric Liang"><meta name="copyright" content="Eric Liang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="07-Atomic类源码解析"><meta name="twitter:description" content="Atomic类源码解析"><meta name="twitter:image" content="https://source.unsplash.com/300x300/?atomic"><meta property="og:type" content="article"><meta property="og:title" content="07-Atomic类源码解析"><meta property="og:url" content="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/07-Atomic%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Eric Liang"><meta property="og:description" content="Atomic类源码解析"><meta property="og:image" content="https://source.unsplash.com/300x300/?atomic"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/07-Atomic%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="prev" title="String源码解析" href="https://ericql.github.io/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81%E7%AF%87/String%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="next" title="11-Java中的锁" href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/11-Java%E4%B8%AD%E7%9A%84%E9%94%81/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Eric Liang</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java原子类解析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java原子类解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CAS原理"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">CAS原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS优点"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">CAS优点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS缺点"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">CAS缺点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS-乐观锁算法-的基本假设前提"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">CAS(乐观锁算法)的基本假设前提</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Unsafe解析"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Unsafe解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主要功能"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">主要功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#普通读写"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">普通读写</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile读写"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">volatile读写</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#有序写入"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">有序写入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#直接内存操作"><span class="toc_mobile_items-number">1.2.5.</span> <span class="toc_mobile_items-text">直接内存操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS相关"><span class="toc_mobile_items-number">1.2.6.</span> <span class="toc_mobile_items-text">CAS相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#偏移量相关"><span class="toc_mobile_items-number">1.2.7.</span> <span class="toc_mobile_items-text">偏移量相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程调度"><span class="toc_mobile_items-number">1.2.8.</span> <span class="toc_mobile_items-text">线程调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类加载"><span class="toc_mobile_items-number">1.2.9.</span> <span class="toc_mobile_items-text">类加载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内存屏障"><span class="toc_mobile_items-number">1.2.10.</span> <span class="toc_mobile_items-text">内存屏障</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#原子类Atomic"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">原子类Atomic</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么会有原子类"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">为什么会有原子类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常用原子类"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">常用原子类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AtomicInteger"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">AtomicInteger</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要变量"><span class="toc_mobile_items-number">1.3.3.1.</span> <span class="toc_mobile_items-text">主要变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#构造方法"><span class="toc_mobile_items-number">1.3.3.2.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要方法"><span class="toc_mobile_items-number">1.3.3.3.</span> <span class="toc_mobile_items-text">主要方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AtomicReference"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">AtomicReference</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要变量-1"><span class="toc_mobile_items-number">1.3.4.1.</span> <span class="toc_mobile_items-text">主要变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#构造方法-1"><span class="toc_mobile_items-number">1.3.4.2.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要方法-1"><span class="toc_mobile_items-number">1.3.4.3.</span> <span class="toc_mobile_items-text">主要方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AtomicStampedReference"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">AtomicStampedReference</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要变量-2"><span class="toc_mobile_items-number">1.3.5.1.</span> <span class="toc_mobile_items-text">主要变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#构造方法-2"><span class="toc_mobile_items-number">1.3.5.2.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要方法-2"><span class="toc_mobile_items-number">1.3.5.3.</span> <span class="toc_mobile_items-text">主要方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#充值示例模拟"><span class="toc_mobile_items-number">1.3.5.4.</span> <span class="toc_mobile_items-text">充值示例模拟</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AtomicIntegerArray"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">AtomicIntegerArray</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要变量-3"><span class="toc_mobile_items-number">1.3.6.1.</span> <span class="toc_mobile_items-text">主要变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#构造方法-3"><span class="toc_mobile_items-number">1.3.6.2.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要方法-3"><span class="toc_mobile_items-number">1.3.6.3.</span> <span class="toc_mobile_items-text">主要方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AtomicIntegerFieldUpdater"><span class="toc_mobile_items-number">1.3.7.</span> <span class="toc_mobile_items-text">AtomicIntegerFieldUpdater</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#构造方法-4"><span class="toc_mobile_items-number">1.3.7.1.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#内部类"><span class="toc_mobile_items-number">1.3.7.2.</span> <span class="toc_mobile_items-text">内部类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要方法-4"><span class="toc_mobile_items-number">1.3.7.3.</span> <span class="toc_mobile_items-text">主要方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#示例代码"><span class="toc_mobile_items-number">1.3.7.4.</span> <span class="toc_mobile_items-text">示例代码</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#无锁Vector"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">无锁Vector</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java原子类解析"><span class="toc-number">1.</span> <span class="toc-text">Java原子类解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS原理"><span class="toc-number">1.1.</span> <span class="toc-text">CAS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS优点"><span class="toc-number">1.1.1.</span> <span class="toc-text">CAS优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS缺点"><span class="toc-number">1.1.2.</span> <span class="toc-text">CAS缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-乐观锁算法-的基本假设前提"><span class="toc-number">1.1.3.</span> <span class="toc-text">CAS(乐观锁算法)的基本假设前提</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe解析"><span class="toc-number">1.2.</span> <span class="toc-text">Unsafe解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要功能"><span class="toc-number">1.2.1.</span> <span class="toc-text">主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通读写"><span class="toc-number">1.2.2.</span> <span class="toc-text">普通读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile读写"><span class="toc-number">1.2.3.</span> <span class="toc-text">volatile读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序写入"><span class="toc-number">1.2.4.</span> <span class="toc-text">有序写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接内存操作"><span class="toc-number">1.2.5.</span> <span class="toc-text">直接内存操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS相关"><span class="toc-number">1.2.6.</span> <span class="toc-text">CAS相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏移量相关"><span class="toc-number">1.2.7.</span> <span class="toc-text">偏移量相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程调度"><span class="toc-number">1.2.8.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载"><span class="toc-number">1.2.9.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存屏障"><span class="toc-number">1.2.10.</span> <span class="toc-text">内存屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原子类Atomic"><span class="toc-number">1.3.</span> <span class="toc-text">原子类Atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么会有原子类"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么会有原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用原子类"><span class="toc-number">1.3.2.</span> <span class="toc-text">常用原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">1.3.3.</span> <span class="toc-text">AtomicInteger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要变量"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">主要变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">主要方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicReference"><span class="toc-number">1.3.4.</span> <span class="toc-text">AtomicReference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要变量-1"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">主要变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法-1"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法-1"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">主要方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">1.3.5.</span> <span class="toc-text">AtomicStampedReference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要变量-2"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">主要变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法-2"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法-2"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#充值示例模拟"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">充值示例模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicIntegerArray"><span class="toc-number">1.3.6.</span> <span class="toc-text">AtomicIntegerArray</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要变量-3"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">主要变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法-3"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法-3"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">主要方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicIntegerFieldUpdater"><span class="toc-number">1.3.7.</span> <span class="toc-text">AtomicIntegerFieldUpdater</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法-4"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法-4"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示例代码"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无锁Vector"><span class="toc-number">1.4.</span> <span class="toc-text">无锁Vector</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://uploadbeta.com/api/pictures/random)"><div id="post-info"><div id="post-title"><div class="posttitle">07-Atomic类源码解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-06</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">02-Java并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/">02-并发包</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Java原子类解析"><a href="#Java原子类解析" class="headerlink" title="Java原子类解析"></a>Java原子类解析</h1><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS算法的过程是这样：<br>&emsp;&emsp;它包含三个参数CAS(V,E,N);V表示要更新的变量,E表示预期值,N表示新值.<br>&emsp;&emsp;仅当V值等于E值时,才会将V的值设为N,如果V值和E值不同,则说明已经有其他线程做了更新,则当前线程什么都不做.最后,CAS返回当前V的真实值<br>&emsp;&emsp;CAS操作是抱着乐观的态度进行的,它总是认为自己可以成功完成操作.当多个线程同时使用CAS操作一个变量时,只有一个会胜出并成功更新,其余均会失败.失败的线程不会被挂起,仅是被告知失败,并且允许再次尝试,当然也允许失败的线程放弃操作.基于这样的原理,CAS操作即使没有锁,也可以发现其他线程对当前线程的干扰,并进行恰当的处理<br>&emsp;&emsp;简单地说,CAS需要你额外给出一个期望值,也就是你认为这个变量现在应该是什么样子的.如果变量不是你想象的那样,那说明它已经被别人修改过了.你就重新读取,再次尝试修改就好了<br>&emsp;&emsp;在硬件层面,大部分的现代处理器都已经支持原子化的CAS指令.在JDK 5.0以后,虚拟机便可以使用这个指令来实现并发操作和并发数据结构,并且这种操作在虚拟机中可以说是无处不在</p>
<h3 id="CAS优点"><a href="#CAS优点" class="headerlink" title="CAS优点"></a>CAS优点</h3><p>&emsp;&emsp;与锁相比,使用比较交换(下文简称CAS)会使程序看起来更加复杂一些.但由于其非阻塞性,它对死锁问题天生免疫,并且线程间的相互影响也远远比基于锁的方式要小.更为重要的是使用无锁的方式完全没有锁竞争带来的系统开销,也没有线程间频繁调度带来的开销,因此它要比基于锁的方式拥有更优越的性能</p>
<ul>
<li>在高并发的情况下,它比有锁的程序拥有更好的性能</li>
<li>它天生就是死锁免疫的<br>就凭借这两个优势,就值得我们冒险尝试使用无锁的并发</li>
</ul>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><p>CAS存在一个很明显的问题,即ABA问题<br>&emsp;&emsp;问题：如果变量V初次读取的时候是A,并且在准备赋值的时候检查到它仍然是A,那能说明它的值没有被其他线程修改过了吗<br>&emsp;&emsp;如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性</p>
<h3 id="CAS-乐观锁算法-的基本假设前提"><a href="#CAS-乐观锁算法-的基本假设前提" class="headerlink" title="CAS(乐观锁算法)的基本假设前提"></a>CAS(乐观锁算法)的基本假设前提</h3><p>CAS比较与交换的伪代码可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    备份旧数据；</span><br><span class="line">    基于旧数据构造新数据；</span><br><span class="line">&#125;while(!CAS( 内存地址，备份的旧数据，新数据 )</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;就是指当两者进行比较时,如果相等,则证明共享数据没有被修改,替换成新值,然后继续往下运行;如果不相等,说明共享数据已经被修改,放弃已经所做的操作,然后重新执行刚才的操作.容易看出CAS操作是基于共享数据不会被修改的假设,采用了类似于数据库的commit-retry的模式.当同步冲突出现的机会很少时,这种假设能带来较大的性能提升</p>
<h2 id="Unsafe解析"><a href="#Unsafe解析" class="headerlink" title="Unsafe解析"></a>Unsafe解析</h2><p>&emsp;&emsp;Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域,不能像C++中那样可以自己申请内存和释放内存.Java中的Unsafe类为我们提供了类似C++手动管理内存的能力.<br>&emsp;&emsp;Unsafe类：全限定名是sun.misc.Unsafe,从名字中我们可以看出来这个类对普通程序员来说是”危险”的,一般应用开发者不会用到这个类</p>
<p>Unsafe类是”final”的,不允许继承.且构造函数是private的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_FIELD_OFFSET = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数是private的,不允许外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">```  </span><br><span class="line">因此我们无法在外部对Unsafe进行实例化</span><br><span class="line">### 获取Unsafe</span><br><span class="line">Unsafe无法实例化,那么怎么获取Unsafe呢?答案就是通过反射来获取Unsafe：</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>Unsafe的功能如下图：<br><img alt="unsafe功能图" data-src class="lazyload">  </p>
<h3 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h3><p>通过Unsafe可以读写一个类的属性,即使这个属性是私有的,也可以对这个属性进行读写  </p>
<p>读写一个Object属性的相关方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;getInt用于从对象的指定偏移地址处读取一个int.putInt用于在对象指定偏移地址处写入一个int.其他的primitive type也有对应的方法</p>
<p>Unsafe还可以直接在一个地址上读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putByte</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">byte</span> var4)</span></span>;</span><br></pre></td></tr></table></figure>
<p>getByte用于从指定内存地址处开始读取一个byte.putByte用于从指定内存地址写入一个byte</p>
<h3 id="volatile读写"><a href="#volatile读写" class="headerlink" title="volatile读写"></a>volatile读写</h3><p>普通的读写无法保证可见性和有序性,而volatile读写就可以保证可见性和有序性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure>
<p>getIntVolatile方法用于在对象指定偏移地址处volatile读取一个int.putIntVolatile方法用于在对象指定偏移地址处volatile写入一个int  </p>
<p>&emsp;&emsp;volatile读写相对普通读写是更加昂贵的,因为需要保证可见性和有序性,而与volatile写入相比putOrderedXX写入代价相对较低,putOrderedXX写入不保证可见性,但是保证有序性,所谓有序性,就是保证指令不会重排序</p>
<h3 id="有序写入"><a href="#有序写入" class="headerlink" title="有序写入"></a>有序写入</h3><p>有序写入只保证写入的有序性,不保证可见性,就是说一个线程的写入不保证其他线程立马可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="直接内存操作"><a href="#直接内存操作" class="headerlink" title="直接内存操作"></a>直接内存操作</h3><p>&emsp;&emsp;我们都知道Java不可以直接对内存进行操作,对象内存的分配和回收都是由JVM帮助我们实现的.但是Unsafe为我们在Java中提供了直接操作内存的能力  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 重新分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"><span class="comment">// 内存初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3, <span class="keyword">byte</span> var5)</span></span>;</span><br><span class="line"><span class="comment">// 内存复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, <span class="keyword">long</span> var5, <span class="keyword">long</span> var7)</span></span>;</span><br><span class="line"><span class="comment">// 清除内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h3><p>JUC中大量运用了CAS操作,可以说CAS操作是JUC的基础,因此CAS操作是非常重要的.Unsafe中提供了int,long和Object的CAS操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure>
<p>CAS一般用于乐观锁,它在Java中有广泛的应用,ConcurrentHashMap，ConcurrentLinkedQueue中都有用到CAS来实现乐观锁</p>
<h3 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;staticFieldOffset方法用于获取静态属性Field在对象中的偏移量,读写静态属性时必须获取其偏移量.objectFieldOffset方法用于获取非静态属性Field在对象实例中的偏移量,读写对象的非静态属性时会用到这个偏移量.staticFieldBase方法用于返回Field所在的对象.arrayBaseOffset方法用于返回数组中第一个元素实际地址相对整个数组对象的地址的偏移量.arrayIndexScale方法用于计算数组中第一个元素所占用的内存空间</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>park方法和unpark方法相信看过LockSupport类的都不会陌生,这两个方法主要用来挂起和唤醒线程.LockSupport中的park和unpark方法正是通过Unsafe来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挂起线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker); <span class="comment">// 通过Unsafe的putObject方法设置阻塞阻塞当前线程的blocker</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>); <span class="comment">// 通过Unsafe的park方法来阻塞当前线程，注意此方法将当前线程阻塞后，当前线程就不会继续往下走了，直到其他线程unpark此线程</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>); <span class="comment">// 清除blocker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>monitorEnter方法和monitorExit方法用于加锁,Java中的synchronized锁就是通过这两个指令来实现的</p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String var1, <span class="keyword">byte</span>[] var2, <span class="keyword">int</span> var3, <span class="keyword">int</span> var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, <span class="keyword">byte</span>[] var2, Object[] var3);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; var1)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>defineClass方法定义一个类,用于动态地创建类.</li>
<li>defineAnonymousClass用于动态的创建一个匿名内部类</li>
<li>allocateInstance方法用于创建一个类的实例,但是不会调用这个实例的构造方法,如果这个类还未被初始化,则初始化这个类</li>
<li>shouldBeInitialized方法用于判断是否需要初始化一个类</li>
<li>ensureClassInitialized方法用于保证已经初始化过一个类</li>
</ul>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>loadFence：保证在这个屏障之前的所有读操作都已经完成<br>storeFence：保证在这个屏障之前的所有写操作都已经完成<br>fullFence：保证在这个屏障之前的所有读写操作都已经完成</p>
<h2 id="原子类Atomic"><a href="#原子类Atomic" class="headerlink" title="原子类Atomic"></a>原子类Atomic</h2><p>java.util.concurrent.atomic包：原子类的小工具包,支持在单个变量上解除锁的线程安全编程<br>&emsp;&emsp;原子变量类相当于一种泛化的volatile变量,能够支持原子的和有条件的读-改-写操作.AtomicInteger表示一个int类型的值,并提供了get和set方法,这些 Volatile类型的int变量在读取和写入上有着相同的内存语义.它还提供了一个原子的compareAndSet方法(如果该方法成功执行,那么将实现与读取/写入一个volatile变量相同的内存效果),以及原子的添加、递增和递减等方法.AtomicInteger表面上非常像一个扩展的Counter类,但在发生竞争的情况下能提供更高的可伸缩性,因为它直接利用了硬件对并发的支持</p>
<h3 id="为什么会有原子类"><a href="#为什么会有原子类" class="headerlink" title="为什么会有原子类"></a>为什么会有原子类</h3><p>jdk5增加了并发包java.util.concurrent.<em>,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁.JDK5之前Java语言是靠synchronized关键字保证同步的,这是一种独占锁,也是是悲观锁<br>*</em>如果同一个变量要被多个线程访问,则可以使用该包中的类**</p>
<h3 id="常用原子类"><a href="#常用原子类" class="headerlink" title="常用原子类"></a>常用原子类</h3><p>Java中的原子操作类大致可以分为4类：<strong>原子更新基本类型、原子更新数组类型、原子更新引用类型、原子更新属性类型</strong>.这些原子类中都是用了无锁的概念,有的地方直接使用CAS操作的线程安全的类型</p>
<ul>
<li>AtomicInteger</li>
<li>AtomicReference</li>
</ul>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>&emsp;&emsp;一个可以自动更新的int值.AtomicInteger用于诸如原子递增计数器之类的应用程序,并且不能替代Integer.但是此类确实扩展了Number,以允许处理基于数字的类的工具和实用程序进行统一访问</p>
<h4 id="主要变量"><a href="#主要变量" class="headerlink" title="主要变量"></a>主要变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为使用Unsafe.compareAndSwapInt进行更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了一个int值对其进行加减</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的初始值创建一个新的AtomicInteger</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新值,并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前值为expect,则设置为u</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能会失败,并且不提供排序保证,因此很少是compareAndSet的适当替代方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值加1,返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值减1,返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值增加delta,返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值加1,返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值减1,返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前值增加delta,返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋式更新值,值为入参给定函数的结果,并返回先前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋式更新值,值为入参给定函数的结果,并返回更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入参给定函数应用于当前值和给定值,以原子方式自旋的更新当前值,并返回先前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x,  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入参给定函数应用于当前值和给定值,以原子方式自旋的更新当前值,并返回更新后的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x,  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>与AtomicInteger类似,只是里面封装了一个对象,而不是int,对引用进行修改</p>
<h4 id="主要变量-1"><a href="#主要变量-1" class="headerlink" title="主要变量"></a>主要变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicReference.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的初始值创建一个新的AtomicReference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置给定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最终设置为给定值,懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值==期望值,则以原子方式将该值设置为给定的更新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可能会失败,并且不提供保证,因此很少是compareAndSet的适当替代方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式设置为给定值并返回旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用入参给定函数的结果以原子方式自旋的更新当前值,并返回先前的值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndUpdate</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span> </span>&#123;</span><br><span class="line">    V prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.apply(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用入参给定函数的结果以原子方式自旋的更新当前值,并返回更新后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">updateAndGet</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span> </span>&#123;</span><br><span class="line">    V prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.apply(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将入参给定函数应用于当前值和入参给定值,以原子方式自旋的更新当前值,并返回先前的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndAccumulate</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    V prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.apply(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将入参给定函数应用于当前值和入参给定值,以原子方式自旋的更新当前值,并返回更新后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">accumulateAndGet</span><span class="params">(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    V prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.apply(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>&emsp;&emsp;AtomicStampedReference维护对象引用以及可以自动更新的整数”标记”,主要通过包装[对象引用, stamp],进行对象引用与stamp的对应绑定,更新stamp来解决ABA问题</p>
<blockquote>
<p>ABA问题：<br>&emsp;&emsp;线程一准备用CAS将变量的值由A替换为B,在此之前线程二将变量的值由A替换为C,线程三又将C替换为A,然后线程一执行CAS时发现变量的值仍然为A,所以线程一CAS成功</p>
</blockquote>
<h4 id="主要变量-2"><a href="#主要变量-2" class="headerlink" title="主要变量"></a>主要变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部封装了一个Pair对象,每次对对象操作的时候,stamp + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的初始值创建一个新的AtomicStampedReference</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pair.reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pair.stamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前的对象引用(返回值)和时间戳(入参返回)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] stampHolder)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; pair = <span class="keyword">this</span>.pair;</span><br><span class="line">    stampHolder[<span class="number">0</span>] = pair.stamp;</span><br><span class="line">    <span class="keyword">return</span> pair.reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能会失败,不提供保证,因此很少是compareAndSet的适当替代方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expectedReference, V newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSet(expectedReference, newReference, expectedStamp, newStamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // CAS操作,会比较stamp值 参数依次为：期望值 写入新值 期望时间戳 新时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference, V   newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前对象引用和时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">if</span> (newReference != current.reference || newStamp != current.stamp)</span><br><span class="line">        <span class="keyword">this</span>.pair = Pair.of(newReference, newStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="充值示例模拟"><a href="#充值示例模拟" class="headerlink" title="充值示例模拟"></a>充值示例模拟</h4><p>后台使用多个线程对用户充值,要求只能充值一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="function"><span class="keyword">public</span> staticvoid <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟多个线程同时更新后台数据库，为用户充值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> timestamp=money.getStamp();</span><br><span class="line">        newThread() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                       Integerm=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&lt;<span class="number">20</span>)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">20</span>,timestamp,timestamp+<span class="number">1</span>))&#123;</span><br><span class="line">      　　　　　　　　　　　　　　　 System.out.println(<span class="string">"余额小于20元，充值成功，余额:"</span>+money.getReference()+<span class="string">"元"</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                           <span class="comment">//System.out.println("余额大于20元，无需充值");</span></span><br><span class="line">                            <span class="keyword">break</span> ;</span><br><span class="line">                         &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;.start();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户消费线程，模拟消费行为</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123; </span><br><span class="line">         <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> timestamp=money.getStamp();</span><br><span class="line">                    Integer m=money.getReference();</span><br><span class="line">                    <span class="keyword">if</span>(m&gt;<span class="number">10</span>)&#123;</span><br><span class="line">                         System.out.println(<span class="string">"大于10元"</span>);</span><br><span class="line">                      　　<span class="keyword">if</span>(money.compareAndSet(m, m-<span class="number">10</span>,timestamp,timestamp+<span class="number">1</span>))&#123;</span><br><span class="line">                  　　　　　　 System.out.println(<span class="string">"成功消费10元，余额:"</span>+money.getReference());</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       System.out.println(<span class="string">"没有足够的金额"</span>);</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;.start(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><p>支持无锁的数组,其中的元素可以原子更新</p>
<h4 id="主要变量-3"><a href="#主要变量-3" class="headerlink" title="主要变量"></a>主要变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">// 数组本身基地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line"><span class="comment">// 封装了一个数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 数组中对象的宽度,int类型,4个字节,scale = 4;</span></span><br><span class="line">    <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前导0个数: 一个数字转为二进制后,他前面0的个数</span></span><br><span class="line">    <span class="comment">// 对于4来讲,他就是00000000 00000000 00000000 00000100,他的前导0个数就是29</span></span><br><span class="line">    <span class="comment">// 所以shift = 2    </span></span><br><span class="line">    shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个给定长度的新AtomicIntegerArray,所有元素最初为零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新AtomicIntegerArray,其长度与给定数组相同,并从给定数组中复制所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终现场保证保证可见性</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第i个元素：在数组中的偏移量是多少</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base: 数组基地址,i &lt;&lt; shift,其实就是i * 4,因为这边是int array.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定位置i的元素设置为给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组第i个下标设置为newValue,并返回旧的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行CAS操作,如果第i个下标的元素等于expect,则设置为update,设置成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第i个下标的元素加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第i个下标的元素减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第i个下标的元素增加delta(delta可以是负数)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原子方式将索引i处的元素加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原子方式将索引i处的元素减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原子方式将给定值添加到索引为i的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用入参给定函数的结果以原子方式自旋的更新索引i处的元素,并返回先前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用入参给定函数的结果以原子方式自旋的更新索引i处的元素,并返回更新后的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入参的给定函数应用于当前值和入参的给定值,以原子方式自旋的更新索引i处的元素,并返回前一个值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入参的给定函数应用于当前值和入参的给定值,以原子方式自旋的更新索引i处的元素,并返回后一个值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>&emsp;&emsp;让普通变量也享受原子操作,基于反射的实用程序,可通过原子更新来指定类别的volatile int个字段.此类设计用于原子数据结构,其中同一节点的多个字段独立地受原子限制更新  </p>
<blockquote>
<p>注意:  compareAndSet的保证该类中的方法比其他原子类中的方法弱.因为此类无法确保该字段的所有用途适用于原子访问.它可以仅在其他调用方面保证原子性在同一更新程序上的compareAndSet和set</p>
</blockquote>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为具有给定字段的对象创建并返回更新程序.需要使用Class参数来检查反射类型和泛型类型是否匹配</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass, String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AtomicIntegerFieldUpdater</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>updater只能修改它可见范围内的变量.因为updater使用反射得到这个变量.如果变量不可见,就会出错.比如如果score申明为private,就是不可行的</li>
<li>为了确保变量被正确的读取,它必须是volatile类型的.如果我们原有代码中未申明这个类型,那么简单得申明一下就行,这不会引起什么问题</li>
<li>由于CAS操作会通过对象实例中的偏移量直接进行赋值,因此它不支持static字段(Unsafe.objectFieldOffset()不支持静态变量)</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果字段受保护,则子类构造Updater,否则与tclass相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; cclass;</span><br><span class="line">    <span class="comment">/** class保持字段 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; tclass;</span><br><span class="line">    </span><br><span class="line">    AtomicIntegerFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass, <span class="keyword">final</span> String fieldName,  <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line">        <span class="keyword">final</span> Field field;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            modifiers = field.getModifiers();</span><br><span class="line">            sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">            ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">            ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">                sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (field.getType() != <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            throw new IllegalArgumentException("Must be integer type");</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 对受保护字段成员的访问仅限于访问类或其子类之一的接收者,并且访问类又必须是受保护成员的定义类的子类(或程序包同级).如果更新程序在当前包外部引用了声明类的受保护字段,则接收器参数将缩小为访问类的类型</span></span><br><span class="line">        <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                       tclass.isAssignableFrom(caller) &amp;&amp;</span><br><span class="line">                       !isSamePackage(tclass, caller))</span><br><span class="line">                      ? caller : tclass;</span><br><span class="line">        <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">        <span class="keyword">this</span>.offset = U.objectFieldOffset(field);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果可以在第一个类加载器的委托链中找到第二个类加载器,则返回true.等效于不可访问的：first.isAncestor(second)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAncestor</span><span class="params">(ClassLoader first, ClassLoader second)</span> </span>&#123;</span><br><span class="line">        ClassLoader acl = first;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            acl = acl.getParent();</span><br><span class="line">            <span class="keyword">if</span> (second == acl) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (acl != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果两个类具有相同的类加载器和包限定符,则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSamePackage</span><span class="params">(Class&lt;?&gt; class1, Class&lt;?&gt; class2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> class1.getClassLoader() == class2.getClassLoader()</span><br><span class="line">               &amp;&amp; Objects.equals(getPackageName(class1), getPackageName(class2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPackageName</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        String cn = cls.getName();</span><br><span class="line">        <span class="keyword">int</span> dot = cn.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">return</span> (dot != -<span class="number">1</span>) ? cn.substring(<span class="number">0</span>, dot) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查目标参数是否是类的实例.失败时,抛出原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">accessCheck</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cclass.isInstance(obj))</span><br><span class="line">            throwAccessCheckException(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        accessCheck(obj);</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapInt(obj, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        accessCheck(obj);</span><br><span class="line">        U.putIntVolatile(obj, offset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        accessCheck(obj);</span><br><span class="line">        <span class="keyword">return</span> U.getIntVolatile(obj, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        accessCheck(obj);</span><br><span class="line">        <span class="keyword">return</span> U.getAndSetInt(obj, offset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(T obj, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        accessCheck(obj);</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(obj, offset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法-4"><a href="#主要方法-4" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前值==期望值,则以原子方式将此更新程序管理的给定对象的字段设置为给定更新值.对于compareAndSet和set的其他调用,此方法保证是原子的,但对于该字段中的其他更改,则不一定是原子的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此更新程序管理的给定对象的字段设置为给定的更新值.对于后续compareAndSet的调用,保证此操作充当易失性存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取在此更新程序管理的给定对象的字段中保留的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(T obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原子方式将此更新程序管理的给定对象的字段设置为给定值,并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原子方式将此更新程序管理的给定对象的字段的当前值增加一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式将此更新器管理的给定对象的字段的当前值减一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式将给定值添加到此更新程序管理的给定对象的字段的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(T obj, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev + delta;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式将此更新程序管理的给定对象的字段的当前值增加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式将此更新器管理的给定对象的字段的当前值减一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式将给定值添加到此更新程序管理的给定对象的字段的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(T obj, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev + delta;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用应用给定功能的结果以原子方式自旋式更新此更新程序管理的给定对象的字段,并返回先前的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(T obj, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用应用给定功能的结果以原子方式自旋式更新此更新程序管理的给定对象的字段,并返回更新后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(T obj, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定函数应用于当前值和给定值,并返回前一个值.以原子方式更新此更新程序管理的给定对象的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(T obj, <span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定函数应用于当前值和给定值,并返回更新后的值.以原子方式更新此更新程序管理的给定对象的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(T obj, <span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="comment">// 如果直接把int改成atomicinteger, 可能对代码破坏比较大</span></span><br><span class="line">        <span class="comment">// 因此使用AtomicIntegerFieldUpdater对score进行封装</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射实现</span></span><br><span class="line">    public final static AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");</span><br><span class="line">    <span class="comment">// 检查Updater是否工作正确, allScore的结果应该跟score一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Candidate stu = <span class="keyword">new</span> Candidate();</span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">                        scoreUpdater.incrementAndGet(stu);</span><br><span class="line">                        allScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"score="</span> + stu.score);</span><br><span class="line">        System.out.println(<span class="string">"allScore="</span> + allScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无锁Vector"><a href="#无锁Vector" class="headerlink" title="无锁Vector"></a>无锁Vector</h2><p>jdk中Vector是加锁的, 网上找的一个无锁Vector LockFreeVector, 给他添加了源码中文注释.</p>
<p>主要关注push_back, 添加元素的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.AbstractList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 它是线程安全且无锁的向量.</span></span><br><span class="line"><span class="comment"> * 该类实现算法来自：</span></span><br><span class="line"><span class="comment"> *     无锁动态可调整大小的阵列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> debug = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个存储桶的大小：sizeof(bucket[i+1])=2*sizeof(bucket[i])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_BUCKET_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶数：30 will allow 8*(2^30-1) elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_BUCKET = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们最多只能有N_BUCKET个桶. 我们有sizeof(buckets.get(i))=FIRST_BUCKET_SIZE**(i+1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么AtomicReferenceArray里再套一个AtomicReferenceArray呢,类似一个篮子(buckets)里放了很多篮子</span></span><br><span class="line"><span class="comment">     * 为了在容量扩展时希望尽可能少的改动原有数据,因此把一维数组扩展成二维数组.</span></span><br><span class="line"><span class="comment">     * 该二维数组并非均衡的分布.可能第一个数组8个元素,第二个数组16个元素,第三个数组32个......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDescriptor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E oldV;</span><br><span class="line">        <span class="keyword">public</span> E newV;</span><br><span class="line">        <span class="keyword">public</span> AtomicReferenceArray&lt;E&gt; addr;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> addr_ind;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的描述符</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> addr Operation address 对哪个数组进行写</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> addr_ind  Index of address 指定index</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> oldV old operand</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> newV new operand</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WriteDescriptor</span><span class="params">(AtomicReferenceArray&lt;E&gt; addr, <span class="keyword">int</span> addr_ind, E oldV, E newV)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.addr = addr;</span><br><span class="line">            <span class="keyword">this</span>.addr_ind = addr_ind;</span><br><span class="line">            <span class="keyword">this</span>.oldV = oldV;</span><br><span class="line">            <span class="keyword">this</span>.newV = newV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这边失败后重试的逻辑在另外的代码里.</span></span><br><span class="line">            addr.compareAndSet(addr_ind, oldV, newV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Descriptor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">volatile</span> WriteDescriptor&lt;E&gt; writeop;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Descriptor</span><span class="params">(<span class="keyword">int</span> size, WriteDescriptor&lt;E&gt; writeop)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">this</span>.writeop = writeop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            WriteDescriptor&lt;E&gt; tmpOp = writeop;</span><br><span class="line">            <span class="keyword">if</span> (tmpOp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmpOp.doIt();</span><br><span class="line">                writeop = <span class="keyword">null</span>; <span class="comment">// 这是安全的,因为所有写入writeop的操作都将null用作r_value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Descriptor&lt;E&gt;&gt; descriptor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> zeroNumFirst = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockFreeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt;(N_BUCKET);</span><br><span class="line">        buckets.set(<span class="number">0</span>, <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(FIRST_BUCKET_SIZE));</span><br><span class="line">        descriptor = <span class="keyword">new</span> AtomicReference&lt;Descriptor&lt;E&gt;&gt;(<span class="keyword">new</span> Descriptor&lt;E&gt;(<span class="number">0</span>,<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把元素e加到vector中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Descriptor&lt;E&gt; desc;</span><br><span class="line">        Descriptor&lt;E&gt; newd;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            desc = descriptor.get();</span><br><span class="line">            desc.completeWrite();</span><br><span class="line">            <span class="comment">// desc.size   Vector 本身的大小</span></span><br><span class="line">            <span class="comment">// FIRST_BUCKET_SIZE  第一个一维数组的大小</span></span><br><span class="line">            <span class="keyword">int</span> pos = desc.size + FIRST_BUCKET_SIZE;</span><br><span class="line">            <span class="comment">// 取出pos 的前导0</span></span><br><span class="line">            <span class="keyword">int</span> zeroNumPos = Integer.numberOfLeadingZeros(pos);</span><br><span class="line">            <span class="comment">// zeroNumFirst  为FIRST_BUCKET_SIZE 的前导0</span></span><br><span class="line">            <span class="comment">// bucketInd 数据应该放到哪一个一维数组(篮子)里的</span></span><br><span class="line">            <span class="keyword">int</span> bucketInd = zeroNumFirst - zeroNumPos;</span><br><span class="line">            <span class="comment">// 00000000 00000000 00000000 00001000 第一个篮子满 8</span></span><br><span class="line">            <span class="comment">// 00000000 00000000 00000000 00011000 第二个篮子满 8 + 16</span></span><br><span class="line">            <span class="comment">// 00000000 00000000 00000000 00111000 第三个篮子满 8 + 16 + 32</span></span><br><span class="line">            <span class="comment">// ... bucketInd其实通过前导0相减, 就是为了得出来当前第几个篮子是空的.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断这个一维数组是否已经启用, 可能是第一次初始化</span></span><br><span class="line">            <span class="keyword">if</span> (buckets.get(bucketInd) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//newLen  一维数组的长度, 取前一个数组长度 * 2</span></span><br><span class="line">                <span class="keyword">int</span> newLen = <span class="number">2</span> * buckets.get(bucketInd - <span class="number">1</span>).length();</span><br><span class="line">                <span class="comment">// 设置失败也没关系, 只要有人初始化成功就行</span></span><br><span class="line">                buckets.compareAndSet(bucketInd, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(newLen));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在这个一位数组中，我在哪个位置</span></span><br><span class="line">            <span class="comment">// 0x80000000是 10000000 00000000 00000000 00000000</span></span><br><span class="line">            <span class="comment">// 这句话就是把上述111000, 第一个1变成了0, 得到011000, 即新值的位置.</span></span><br><span class="line">            <span class="keyword">int</span> idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;</span><br><span class="line">            <span class="comment">// 通过bucketInd与idx来确定元素在二维数组中的位置</span></span><br><span class="line">            <span class="comment">// 期望写入的时候, 该位置值是null, 如果非null, 说明其他线程已经写了, 则继续循环.</span></span><br><span class="line">            newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size + <span class="number">1</span>, <span class="keyword">new</span> WriteDescriptor&lt;E&gt;(</span><br><span class="line">                    buckets.get(bucketInd), idx, <span class="keyword">null</span>, e));</span><br><span class="line">            <span class="comment">// 循环cas设值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line">        descriptor.get().completeWrite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除向量中的最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Descriptor&lt;E&gt; desc;</span><br><span class="line">        Descriptor&lt;E&gt; newd;</span><br><span class="line">        E elem;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            desc = descriptor.get();</span><br><span class="line">            desc.completeWrite();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos = desc.size + FIRST_BUCKET_SIZE - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                    - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">            <span class="keyword">int</span> idx = Integer.highestOneBit(pos) ^ pos;</span><br><span class="line">            elem = buckets.get(bucketInd).get(idx);</span><br><span class="line">            newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size - <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取带有索引的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = index + FIRST_BUCKET_SIZE;</span><br><span class="line">        <span class="keyword">int</span> zeroNumPos = Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        <span class="keyword">int</span> bucketInd = zeroNumFirst - zeroNumPos;</span><br><span class="line">        <span class="keyword">int</span> idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;</span><br><span class="line">        <span class="keyword">return</span> buckets.get(bucketInd).get(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将具有索引的元素设置为e。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = index + FIRST_BUCKET_SIZE;</span><br><span class="line">        <span class="keyword">int</span> bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        <span class="keyword">int</span> idx = Integer.highestOneBit(pos) ^ pos;</span><br><span class="line">        AtomicReferenceArray&lt;E&gt; bucket = buckets.get(bucketInd);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            E oldV = bucket.get(idx);</span><br><span class="line">            <span class="keyword">if</span> (bucket.compareAndSet(idx, oldV, e))</span><br><span class="line">                <span class="keyword">return</span> oldV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保留更多空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = descriptor.get().size;</span><br><span class="line">        <span class="keyword">int</span> pos = size + FIRST_BUCKET_SIZE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(pos);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> initialSize = buckets.get(i - <span class="number">1</span>).length();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)</span><br><span class="line">                - Integer.numberOfLeadingZeros(newSize + FIRST_BUCKET_SIZE - <span class="number">1</span>)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            initialSize *= FIRST_BUCKET_SIZE;</span><br><span class="line">            buckets.compareAndSet(i, <span class="keyword">null</span>, <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(</span><br><span class="line">                    initialSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> descriptor.get().size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E object)</span> </span>&#123;</span><br><span class="line">        push_back(object);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Eric Liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/07-Atomic%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://ericql.github.io/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-%E5%B9%B6%E5%8F%91%E5%8C%85/07-Atomic%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ericql.github.io">Eric Liang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程    </a></div><div class="post_share"><div class="social-share" data-image="https://source.unsplash.com/300x300/?atomic" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/12/01-Java%E5%9F%BA%E7%A1%80%E7%AF%87/02-JDK%E6%BA%90%E7%A0%81%E7%AF%87/String%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="prev_cover lazyload" data-src="https://source.unsplash.com/300x300/?cartoon" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>String源码解析</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/12/02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01-%E5%BA%94%E7%94%A8%E7%AF%87/11-Java%E4%B8%AD%E7%9A%84%E9%94%81/"><img class="next_cover lazyload" data-src="https://source.unsplash.com/300x300/?java" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>11-Java中的锁</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/15-Java中的并发工具类/" title="15-Java中的并发工具类"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?tools"><div class="relatedPosts_title">15-Java中的并发工具类</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/02-Runnable和Callable接口解析/" title="02-Runnable和Callable接口解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?run"><div class="relatedPosts_title">02-Runnable和Callable接口解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/01-应用篇/06-原子操作的实现与原理/" title="原子操作的实现与原理"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cartoon"><div class="relatedPosts_title">原子操作的实现与原理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/11-并发工具类CyclicBarrier源码解析/" title="11-并发工具类CyclicBarrier源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?cyclic"><div class="relatedPosts_title">11-并发工具类CyclicBarrier源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/10-并发工具类CountDownLatch源码解析/" title="10-并发工具类CountDownLatch源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?countdown"><div class="relatedPosts_title">10-并发工具类CountDownLatch源码解析</div></a></div><div class="relatedPosts_item"><a href="/2019/11/12/02-Java并发编程/02-并发包/09-并发工具类Semaphore源码解析/" title="09-并发工具类Semaphore源码解析"><img class="relatedPosts_cover lazyload"data-src="https://source.unsplash.com/300x300/?semaphore"><div class="relatedPosts_title">09-并发工具类Semaphore源码解析</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By Eric Liang</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><a href="https://ericql.github.io">欢饮来到Eric的博客</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>